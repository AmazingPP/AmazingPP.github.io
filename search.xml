<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>让Task支持带超时的非阻塞异步等待</title>
    <url>/2019/05/12/async-wait-task-with-timeout/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>大家都知道Task表示一个异步任务。如果我们想等待一个Task完成，有很多自带的实例、静态方法供我们选择。有的阻塞，有的不阻塞。不过带超时的等待只有一个，而且它是堵塞的。</p>
<p>这次给大家写个非阻塞的带超时的等待方法~ <a id="more"></a> # Task已有的等待方法</p>
<p>Task实例已有的等待方法就是<code>Wait</code>： <img data-src="/2019/05/12/async-wait-task-with-timeout/instance-methods.png" class=""> ▲ 五个重载，一个无限等待，一个支持取消，两个支持超时（毫秒和<code>TimeSpan</code>），一个既支持取消也支持超时</p>
<p>但Task实例的等待方法的所有重载都有一个弊端，那就是<strong>阻塞</strong>。如果真的用这个方法来等待这个Task，那么一定会堵塞一个线程。所以通常不建议这样直接等待。</p>
<p>另外，Task还提供了静态的等待方法： <img data-src="/2019/05/12/async-wait-task-with-timeout/static-methods.png" class=""> ▲ Task静态的等待方法</p>
<p><code>Task.WaitAll</code>和<code>Task.WaitAny</code>的功能基本和Task实例的<code>Wait</code>方法是一样的，只是可以等待多个Task的实例罢了。</p>
<p>而<code>Task.WhenAll</code>和<code>WhenAny</code>才是<strong>不阻塞</strong>线程的异步等待。</p>
<p>可是！可以看上图，只有<code>Task.Wait</code>系列的重载才有timout参数，也就是超时功能，而<code>Task.When</code>系列则没有。</p>
<p>这也就是本文要讨论和解决的问题。如何让一个Task的等待既可以有超时功能，又是异步的不堵塞线程呢？</p>
<h1 id="带超时的异步非阻塞等待方法的实现">带超时的异步非阻塞等待方法的实现</h1>
<p>Task有一个<code>Task.Delay</code>静态方法，它是用来创建一个在指定时间延迟后完成的任务，类似于一个异步的<code>Thread.Sleep</code>。而我们就可以用这个方法来间接实现异步非阻塞的等待。</p>
<p><code>Task.WhenAny</code>可以异步的等待多个任务中任意一个任务的完成。这样就可以和<code>Task.Delay</code>做一个结合。思路就是要么是真正在执行的任务先完成，要么就是超时先完成。于是我们可以用<code>Task.Delay</code>来创建一个新的Task，来比较两个Task的执行先后：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">TResult</span>&gt; <span class="title">WaitAsync</span>&lt;<span class="title">TResult</span>&gt;(<span class="params">Task&lt;TResult&gt; task, TimeSpan timeout</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">await</span> Task.WhenAny(task, Task.Delay(timeout)) == task)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">&quot;The operation has timed out.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这个扩展封装还不够好，如果我们的任务早已完成，但timeout设置的过长，那么<code>Task.Delay</code>创建的延时任务会一直等到timeout设置的时间结束后才结束，会一直常驻后台，占用资源。</p>
<p>还好延时任务可以被取消，于是我们可以用CancellationTokenSource，把无用的延时任务给释放掉。</p>
<p>然后就有了以下完整的封装：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">AmazingPP</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TaskWaitingExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">WaitAsync</span>(<span class="params"><span class="keyword">this</span> Task task,TimeSpan timeout</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> timeoutCancellationTokenSource = <span class="keyword">new</span> CancellationTokenSource())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> delayTask = Task.Delay(timeout, timeoutCancellationTokenSource.Token);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">await</span> Task.WhenAny(task,delayTask) == task)</span><br><span class="line">                &#123;</span><br><span class="line">                    timeoutCancellationTokenSource.Cancel();</span><br><span class="line">                    <span class="keyword">await</span> task;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">&quot;The opertion has timed out.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">TResult</span>&gt; <span class="title">WaitAsync</span>&lt;<span class="title">TResult</span>&gt;(<span class="params"><span class="keyword">this</span> Task&lt;TResult&gt; task, TimeSpan timeout</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> timeoutCancellationTokenSource = <span class="keyword">new</span> CancellationTokenSource())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> delayTask = Task.Delay(timeout, timeoutCancellationTokenSource.Token);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">await</span> Task.WhenAny(task, delayTask) == task)</span><br><span class="line">                &#123;</span><br><span class="line">                    timeoutCancellationTokenSource.Cancel();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">await</span> task;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">&quot;The operation has timed out.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以在任意的Task实例上调用<code>myTask.WaitAsync</code>来获取带超时的非阻塞异步等待了~~</p>
<blockquote>
<p>参考资料 - [c# - Asynchronously wait for Task to complete with timeout - Stack Overflow](https://stackoverflow.com/q/4238345/6233938)</p>
</blockquote>
]]></content>
      <categories>
        <category>.NET</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>创建委托以大幅度提高反射调用的性能</title>
    <url>/2019/08/07/create-delegate-to-improve-reflection-performance/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>反射这种东西，大家都知道伤性能，但有的时候就是不得不用反射。那咋办呢？</p>
<p>那就是为反射得到的方法创建一个委托！</p>
<p>这种方式能够提高近乎直接调用方法本身的性能。 （当然Emit也能够帮助我们显著提升性能，不过直接得到可以调用的委托岂不是更加方便</p>
<a id="more"></a>
<p>咱们先创建一个类，用来做测试 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先创建一个实例</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用的目标实例。</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>
<p>一般来说，我们调用方法直接可以这样写：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = instance.Test(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>这样写无疑是最不损耗性能的写法，所以是直接调用。</p>
<p>既然博文标题都说了是创建反射的委托，那咱们就先直接写个和Test方法功能一样的纯委托，用作性能对比测试</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跟被测方法功能一样的纯委托。</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pureFunc = <span class="keyword">value</span> =&gt; <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>
<p>下面是反射的使用，先写个通过反射拿到方法 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用反射找到的方法。</span></span><br><span class="line"><span class="keyword">var</span> method = <span class="keyword">typeof</span>(Foo).GetMethod(<span class="keyword">nameof</span>(Foo.Test), <span class="keyword">new</span>[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br></pre></td></tr></table></figure></p>
<p>拿到方法后就是调用，如果是直接调用，那么就是</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = method.Invoke(instance, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">5</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>当然，这个是先用GetMethod拿到方法缓存后的调用。如果是直接使用反射调用的话</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">typeof</span>(Foo).GetMethod(<span class="keyword">nameof</span>(Foo.Test), <span class="keyword">new</span>[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;)?.Invoke(instance, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">5</span> &#125;);</span><br></pre></td></tr></table></figure>
<p><strong><em>下面就是本文的重点</em></strong></p>
<p>那就是将反射找到的方法创建一个委托</p>
<h1 id="如何实现">如何实现？</h1>
<p>实现的关键就在于 <code>MethodInfo.CreateDelegate</code> 方法。这是 .NET Standard 中就有的方法，这意味着 .NET Framework 和 .NET Core 中都可以使用。</p>
<p>此方法有两个重载：</p>
<blockquote>
<p>1.要求传入一个类型，而这个类型就是应该转成的委托的类型 2.要求传入一个类型和一个实例，一样的，类型是应该转成的委托的类型</p>
</blockquote>
<p>他们的区别在于前者创建出来的委托是直接调用那个实例方法本身，后者则更原始一些，真正调用的时候还需要传入一个实例对象。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将反射找到的方法创建一个委托。</span></span><br><span class="line"><span class="keyword">var</span> func = (Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;)method.CreateDelegate(<span class="keyword">typeof</span>(Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;), instance);</span><br><span class="line"><span class="keyword">var</span> func2 = (Func&lt;Foo, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;)method.CreateDelegate(<span class="keyword">typeof</span>(Func&lt;Foo,<span class="built_in">int</span>, <span class="built_in">int</span>&gt;));</span><br></pre></td></tr></table></figure>
<p>前者得到的委托相当于 <code>int Test(int i)</code> 方法，后者得到的委托相当于 <code>int Test(Foo instance, int i)</code> 方法。（在 IL 里实例的方法其实都是后者，而前者更像 C# 中的代码，容易理解。）</p>
<p>以下是性能测试代码，可以更好的理解本文：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics.Contracts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp10</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用的目标实例。</span></span><br><span class="line">            <span class="keyword">var</span> instance = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用反射找到的方法。</span></span><br><span class="line">            <span class="keyword">var</span> method = <span class="keyword">typeof</span>(Foo).GetMethod(<span class="keyword">nameof</span>(Foo.Test), <span class="keyword">new</span>[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将反射找到的方法创建一个委托。</span></span><br><span class="line">            <span class="keyword">var</span> func = InstanceMethodBuilder&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;.CreateInstanceMethod(instance, method);</span><br><span class="line">            <span class="comment">//var func = (Func&lt;int, int&gt;)method.CreateDelegate(typeof(Func&lt;int, int&gt;), instance);</span></span><br><span class="line">            <span class="comment">//var func2 = (Func&lt;Foo, int, int&gt;)method.CreateDelegate(typeof(Func&lt;Foo,int, int&gt;));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跟被测方法功能一样的纯委托。</span></span><br><span class="line">            Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; pureFunc = <span class="keyword">value</span> =&gt; <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 测试次数。</span></span><br><span class="line">            <span class="keyword">var</span> count = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接调用。</span></span><br><span class="line">            <span class="keyword">var</span> watch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">            watch.Start();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> result = instance.Test(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            watch.Stop();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;watch.Elapsed&#125;</span> - <span class="subst">&#123;count&#125;</span> 次 - 直接调用&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用同样功能的 Func 调用。</span></span><br><span class="line">            watch.Restart();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> result = pureFunc(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            watch.Stop();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;watch.Elapsed&#125;</span> - <span class="subst">&#123;count&#125;</span> 次 - 使用同样功能的 Func 调用&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用反射创建出来的委托调用。</span></span><br><span class="line">            watch.Restart();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> result = func(<span class="number">5</span>);</span><br><span class="line">                <span class="comment">//var result = func2(instance,5);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            watch.Stop();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;watch.Elapsed&#125;</span> - <span class="subst">&#123;count&#125;</span> 次 - 使用反射创建出来的委托调用&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用反射得到的方法缓存调用。</span></span><br><span class="line">            watch.Restart();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> result = method.Invoke(instance, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">5</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            watch.Stop();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;watch.Elapsed&#125;</span> - <span class="subst">&#123;count&#125;</span> 次 - 使用反射得到的方法缓存调用&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接使用反射调用。</span></span><br><span class="line">            watch.Restart();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> result = <span class="keyword">typeof</span>(Foo).GetMethod(<span class="keyword">nameof</span>(Foo.Test), <span class="keyword">new</span>[] &#123; <span class="keyword">typeof</span>(<span class="built_in">int</span>) &#125;)</span><br><span class="line">                    ?.Invoke(instance, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">5</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            watch.Stop();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;watch.Elapsed&#125;</span> - <span class="subst">&#123;count&#125;</span> 次 - 直接使用反射调用&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Foo</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">InstanceMethodBuilder</span>&lt;<span class="title">T</span>, <span class="title">TReturnValue</span>&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 调用时就像 var result = func(t)。</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            [<span class="meta">Pure</span>]</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Func</span>&lt;<span class="title">T</span>, <span class="title">TReturnValue</span>&gt; <span class="title">CreateInstanceMethod</span>&lt;<span class="title">TInstanceType</span>&gt;(<span class="params">TInstanceType instance, MethodInfo method</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(instance));</span><br><span class="line">                <span class="keyword">if</span> (method == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(method));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (Func&lt;T, TReturnValue&gt;)method.CreateDelegate(<span class="keyword">typeof</span>(Func&lt;T, TReturnValue&gt;), instance);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> 调用时就像 var result = func(this, t)。</span></span><br><span class="line">            <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">            [<span class="meta">Pure</span>]</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Func</span>&lt;<span class="title">TInstanceType</span>, <span class="title">T</span>, <span class="title">TReturnValue</span>&gt; <span class="title">CreateMethod</span>&lt;<span class="title">TInstanceType</span>&gt;(<span class="params">MethodInfo method</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (method == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(method));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (Func&lt;TInstanceType, T, TReturnValue&gt;)method.CreateDelegate(<span class="keyword">typeof</span>(Func&lt;TInstanceType, T, TReturnValue&gt;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="性能对比">性能对比：</h1>
<img data-src="/2019/08/07/create-delegate-to-improve-reflection-performance/output.png" class="">
<p>解释一下这五行数据的含义：</p>
<p>1.直接调用（应该没有什么比直接调用函数本身更有性能优势的吧）</p>
<p>2.做一个跟直接调用的方法功能一模一样的委托（目的是看看调用委托相比调用方法本身是否有性能损失，从数据上看，损失非常小）</p>
<p>3.<strong><em>本文重点</em></strong> 将反射出来的方法创建一个委托，然后调用这个委托（看看吧，性能跟直接调差别也不大嘛）</p>
<p>4.先反射得到方法，然后一直调用这个方法（终于可以看出来反射本身还是挺伤性能的了，50 多倍的性能损失啊）</p>
<p>5.缓存都不用，从头开始反射然后调用得到的方法（100 多倍的性能损失了）</p>
<h1 id="封装">封装：</h1>
<p>单独使用 <code>CreateDelegate</code> 方法可能每次都需要尝试第一个参数到底应该传入些什么，于是我将其封装成了泛型版本，增加易用性。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">InstanceMethodBuilder</span>&lt;<span class="title">T</span>, <span class="title">TReturnValue</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 调用时就像 var result = func(t)。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Pure</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Func</span>&lt;<span class="title">T</span>, <span class="title">TReturnValue</span>&gt; <span class="title">CreateInstanceMethod</span>&lt;<span class="title">TInstanceType</span>&gt;(<span class="params">TInstanceType instance, MethodInfo method</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(instance));</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(method));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Func&lt;T, TReturnValue&gt;)method.CreateDelegate(<span class="keyword">typeof</span>(Func&lt;T, TReturnValue&gt;), instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 调用时就像 var result = func(this, t)。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Pure</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">Func</span>&lt;<span class="title">TInstanceType</span>, <span class="title">T</span>, <span class="title">TReturnValue</span>&gt; <span class="title">CreateMethod</span>&lt;<span class="title">TInstanceType</span>&gt;(<span class="params">MethodInfo method</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(method));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Func&lt;TInstanceType, T, TReturnValue&gt;)method.CreateDelegate(<span class="keyword">typeof</span>(Func&lt;TInstanceType, T, TReturnValue&gt;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个泛型封装也是有问题的，也就是创建的委托只能是一个参数。没有实现像Action&lt;T1,T2,T3,Tn&gt;这样的多参数委托</p>
<p>不过多参数版本可以使用泛型类型生成器生成。</p>
<p>不过这个日后再说，之后有时间再给大家写一个泛型生成器</p>
]]></content>
      <categories>
        <category>.NET</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>请我吃个饭团！</title>
    <url>/2018/12/25/donate/</url>
    <content><![CDATA[<h1 id="捐赠">捐赠🧧</h1>
<p>感谢您的捐赠，它将给予我动力，更专注于 Github 上项目的后续开发。</p>
<p>再次感谢您的支持。 <a id="more"></a> </br> <img data-src="/2018/12/25/donate/donate.jpg" class=""></p>
]]></content>
  </entry>
  <entry>
    <title>深入剖析IEnumerable和IQueryable两接口</title>
    <url>/2019/03/03/dotnet-IEnumerable-IQueryable/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>日常开发过程中，经常会遇到<code>IEnumerable</code>和<code>IQueryable</code>这两个接口，也许大家也能熟练的运用这两个接口对数据库或者集合进行各种复杂查询。</p>
<p>实际上如果错误的使用，会导致很多很多系统优化，查询效率等等问题。以及很多人吐槽<code>EntityFramework</code>效率低下。实际上<strong>很大原因就是<code>IEnumerable</code>和<code>IQueryable</code>使用的问题！</strong></p>
<p>那么，它们究竟是如何定义的，都分别用来干什么的？又尤其是<code>IQueryable</code>，它和EntityFramework的延迟加载技术又有什么联系呢？</p>
<a id="more"></a>
<h1 id="定义">定义</h1>
<blockquote>
<ul>
<li><code>Enumerable</code>类，继承自<code>IEnumerable&lt;T&gt;</code>接口的集合进行扩展</li>
<li><code>Queryable</code>类，继承自<code>IQueryable&lt;T&gt;</code>接口的集合进行扩展</li>
</ul>
</blockquote>
<p>既然说到EntityFramework，那么就要看一下EntityFramework的实体集合<code>DbSet&lt;T&gt;</code></p>
<img data-src="/2019/03/03/dotnet-IEnumerable-IQueryable/DbSet.png" class="">
<p>从定义上看，<code>DbSet&lt;T&gt;</code>也同时实现了<code>IEnumerable&lt;T&gt;</code>和<code>IQueryable&lt;T&gt;</code>。也就意味着<code>DbSet&lt;T&gt;</code>通过实现<code>IEnumerable&lt;T&gt;</code>和<code>IQueryable&lt;T&gt;</code>的基础上，可以拥有<code>Enumerable</code>和<code>Queryable</code>这两个静态类的很多方法的扩展。</p>
<h1 id="从扩展方法上分辨区别">从扩展方法上分辨区别</h1>
<p>### <code>Enumerable</code>: <img data-src="/2019/03/03/dotnet-IEnumerable-IQueryable/Enumerable-define.png" class=""> ### <code>Queryable</code>: <img data-src="/2019/03/03/dotnet-IEnumerable-IQueryable/Queryable-define.png" class=""></p>
<p>上面两张图可以看出 <code>Enumerable</code>和<code>Queryable</code>下的扩展方法第二个参数是分别是<code>Func&lt;T&gt;</code>和<code>Expression&lt;Func&lt;T&gt;&gt;</code></p>
<p>这就有疑问了，难道我们平时用的<code>Where()</code>等扩展方法，原来有时候都不是同一个方法么？</p>
<p>其实我们反编译仔细观察<code>IQueryable</code>的话，实际上也继承了<code>IEnumerable</code>，所以这两个接口的方法，在很大程度上是一样的，那么，微软为什么要设计出两套扩展方法呢？</p>
<p>好，下面继续深入研究一下。</p>
<p>为了方便大家更直观的理解，接下来就用代码驱动了，透过现象看本质。</p>
<blockquote>
<p>我们先创个控制台项目，把EntityFramework包引入，顺便建一个测试用的MSSQL数据库，以及实体和数据库上下文</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp9</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> db = <span class="keyword">new</span> testEntities())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> query = db.Set&lt;User&gt;().Where(e =&gt; e.UserName == <span class="string">&quot;小红&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//var query = db.Set&lt;User&gt;().AsEnumerable().Where(e =&gt; e.UserName == &quot;小红&quot;);</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> query)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(item.UserName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先注意下<code>query</code>变量的类型 <img data-src="/2019/03/03/dotnet-IEnumerable-IQueryable/query-type.png" class=""></p>
<p>可以看到<code>query</code>是个<code>IQueryable&lt;User&gt;</code>，也就是说，<code>DbSet&lt;T&gt;</code>的<code>Where()</code>方法，默认是来自<code>Queryable</code>下的扩展方法</p>
<p>我们都知道所有的ORM框架，包括EntityFramework，都是将代码转换成SQL语句来对数据库进行操作。所以我们就要从生成的SQL语句来对比<code>IEnumerable</code>和<code>IQueryable</code></p>
<h3 id="ienumerable"><code>IEnumerable</code>:</h3>
<img data-src="/2019/03/03/dotnet-IEnumerable-IQueryable/IEnumerable.png" class="">
<h3 id="iqueryable"><code>IQueryable</code>:</h3>
<img data-src="/2019/03/03/dotnet-IEnumerable-IQueryable/IQueryable.png" class="">
<p><strong>对比生成的SQL语句，我们发现，IEnumerable进行筛选的时候，没有where条件！</strong></p>
<p><strong>也就是说，IEnumerable会将数据库里所有的数据全部取过来，然后再在内存里进行查询！</strong></p>
<h1 id="结论">结论</h1>
<p>1.对于<code>IEnumerable</code>的过滤、排序、分组、聚合等操作，都是在内存中进行的。</p>
<p>2.对于<code>IQueryable</code>的过滤、排序、分组、聚合等操作，Linq to SQL引擎会把表达式树转化成相应的SQL语句在数据库中执行，这也是Linq的延迟加载核心思想所在。</p>
<p>其实<code>IQueryable</code>实现了<code>IEnumerable</code>接口。但多了几个属性 <img data-src="/2019/03/03/dotnet-IEnumerable-IQueryable/IQueryable-define.png" class=""></p>
<p>看到这里，想必就能解释为什么<code>IQueryable</code>，会比<code>IEnumerable</code>传递委托时，会多套上一个<code>Expression</code></p>
<p>答案就在于：<code>Expression</code>会把查询表达式生成表达式树缓存起来，只有当真正需要用到的时候，才会由<code>IQueryProvider</code>解析表达式树，翻译成sql语句执行数据库查询操作。而Func是个委托，必须要先执行完才能进行下一个方法的调用。</p>
<p>更直白点的说，就是：<code>IQueryable</code>是负责生成SQL语句的，但并不马上执行；而<code>IEnumerable</code>是对任意类型的集合都能操作。</p>
<h1 id="引出的代码规范">引出的代码规范</h1>
<ul>
<li>操作<strong>本地</strong>数据源时用IEnumerable</li>
<li>操作<strong>远程</strong>数据源时用IQueryable</li>
</ul>
]]></content>
      <categories>
        <category>.NET</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>EntityFramework</tag>
        <tag>ORM框架</tag>
        <tag>延迟查询</tag>
      </tags>
  </entry>
  <entry>
    <title>支持单字通配符的Sunday模糊匹配算法</title>
    <url>/2021/02/23/fuzzy-matching-algorithm-supporting-wildcard-based-on-Sunday/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>忙碌的春节过去了（吐槽一下，现在南京不给放炮仗，真是越来越没有年味了，不但是礼炮，连擦炮、摔炮都买不到），终于能闲下来学习和写博文了。今天填一下上篇文章留下的坑。实现一个支持单字通配符的Sunday模糊匹配算法</p>
<a id="more"></a>
<h1 id="假定需求">假定需求</h1>
<p>给定一个 haystack 字符串和一个 needle 字符串，实现一个支持 <code>'?'</code> 的单字通配符匹配算法。在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)，如果不存在，则返回 -1。</p>
<h3 id="示例-1">示例 1:</h3>
<blockquote>
<p>输入: haystack = "hello", needle = "l?o" 输出: 2</p>
</blockquote>
<h3 id="示例-2">示例 2:</h3>
<blockquote>
<p>输入: haystack = "aaaaa", needle = "b?a" 输出: -1</p>
</blockquote>
<blockquote>
<ul>
<li>本文算法复杂度中的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="2.378ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 1051 683" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D440"></use></g></g></g></svg></mjx-container>是模式串的长度，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="2.009ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 888 683" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D441"></use></g></g></g></svg></mjx-container>是主串的长度。</li>
<li><code>i</code>代表主串指针，<code>j</code>代表模式串指针，<code>?</code>代表单字通配符</li>
</ul>
</blockquote>
<h1 id="朴素解法暴力匹配">朴素解法（暴力匹配）</h1>
<p>每次<code>j</code>向后移动1步，逐个对比，遇到<code>?</code>就跳过；遇到不匹配的，<code>i</code>向后移动1步, <code>j</code>再从头对比</p>
<h2 id="实现">实现</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">patternMatch</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h_len = haystack.<span class="built_in">size</span>(), n_len = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n_len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= h_len - n_len; ++i) &#123; <span class="comment">// i 主串指针</span></span><br><span class="line">            <span class="type">bool</span> found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n_len; ++j) &#123; <span class="comment">// j 模式串指针</span></span><br><span class="line">                <span class="keyword">if</span> (needle[j] == <span class="string">&#x27;?&#x27;</span>) <span class="comment">// 遇到通配符，跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">                    found = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) <span class="comment">// 匹配，返回索引</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li>预处理时间复杂度：<em>无</em></li>
<li>匹配时间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.873ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3480 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-1-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-1-TEX-I-1D440"></use></g><g data-mml-node="mi" transform="translate(2203, 0)"><use xlink:href="#MJX-1-TEX-I-1D441"></use></g><g data-mml-node="mo" transform="translate(3091, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
<li>空间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(1152, 0)"><use xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(1652, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
</ul>
<h1 id="sunday解法">Sunday解法</h1>
<h2 id="标准sunday需要什么改进">标准Sunday需要什么改进?</h2>
<p>之前介绍过标准的Sunday算法是通过偏移表，在匹配失败时，<strong>确定</strong>需要移动多少，然后让<code>i</code>去位移</p>
<p>但由于<code>?</code>可以代表任意一个字符，所以我们<strong>无法在预处理阶段就确定</strong>需要移动多少，只能根据模式串中最后的<code>?</code>确定<strong>最少</strong>需要移动多少。那么我们就需要让<code>?</code>的偏移量动态更新</p>
<h2 id="如何动态更新通配符的偏移量">如何动态更新通配符的偏移量</h2>
<p>每次对比中<code>j</code>只要遇到了<code>?</code>，就将偏移量更新进去。如果<code>j</code>从来没遇到过<code>?</code>，就使用通配符最小偏移。</p>
<h2 id="字符偏移表和通配符偏移量如果同时存在应该如何选择">字符偏移表和通配符偏移量如果同时存在，应该如何选择?</h2>
<p>答案：选择字符偏移表</p>
<p>为什么：因为能直接将模式串和匹配的末尾字符的下一位对齐</p>
<h2 id="实现-1">实现</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">patternMatch</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h_len = haystack.<span class="built_in">size</span>(), n_len = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n_len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 预处理</span></span><br><span class="line">        <span class="type">int</span> shift[<span class="number">0xFF</span> + <span class="number">1</span>]&#123;&#125;; <span class="comment">// 字符偏移表</span></span><br><span class="line">        <span class="type">int</span> wildcard_min_shitf = <span class="number">0</span>;  <span class="comment">// 通配符最小偏移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (needle[i] == <span class="string">&#x27;?&#x27;</span>)<span class="comment">// 将 ? 的最小偏移量存到 wildcard_min_shitf 里</span></span><br><span class="line">                wildcard_min_shitf = n_len - i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                shift[needle[i]] = n_len - i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= h_len - n_len;) &#123; <span class="comment">// i 主串指针</span></span><br><span class="line">            <span class="type">bool</span> found = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> step = wildcard_min_shitf; <span class="comment">// 每次对比之前重置为最小偏移量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n_len; ++j) &#123; <span class="comment">// j 模式串指针</span></span><br><span class="line">                <span class="keyword">if</span> (needle[j] == <span class="string">&#x27;?&#x27;</span>) <span class="comment">// 遇到?，更新通配符偏移</span></span><br><span class="line">                    step = n_len - j;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123;  <span class="comment">// 不匹配</span></span><br><span class="line">                    found = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found)  <span class="comment">// 匹配，返回索引</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不匹配，如果参与匹配的末尾字符的下一位在字符偏移表里，就使用字符偏移量</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="type">int</span> shift_step = shift[haystack[i + n_len]]) &#123;</span><br><span class="line">                step = shift_step; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (step &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                i += step;  <span class="comment">// 出现在模式串中，按偏移量跳过</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i += n_len + <span class="number">1</span>; <span class="comment">// 没出现在模式串中，跳过模式串长度 + 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析-1">复杂度分析</h2>
<ul>
<li>预处理时间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.864ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2592 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-1-TEX-I-1D440"></use></g><g data-mml-node="mo" transform="translate(2203, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
<li>匹配时间复杂度：
<ul>
<li>平均：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2429 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-1-TEX-I-1D441"></use></g><g data-mml-node="mo" transform="translate(2040, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
<li>最好：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="6.163ex" height="2.765ex" role="img" focusable="false" viewBox="0 -877 2724.2 1222" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-1-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mfrac" transform="translate(1152, 0)"><g data-mml-node="mi" transform="translate(277.6, 394) scale(0.707)"><use xlink:href="#MJX-1-TEX-I-1D441"></use></g><g data-mml-node="mi" transform="translate(220, -345) scale(0.707)"><use xlink:href="#MJX-1-TEX-I-1D440"></use></g><rect width="943.2" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(2335.2, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
<li>最差：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.873ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3480 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-1-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-1-TEX-I-1D440"></use></g><g data-mml-node="mi" transform="translate(2203, 0)"><use xlink:href="#MJX-1-TEX-I-1D441"></use></g><g data-mml-node="mo" transform="translate(3091, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
</ul></li>
<li>空间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.864ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2592 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-1-TEX-I-1D440"></use></g><g data-mml-node="mo" transform="translate(2203, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
</ul>
<h1 id="实际情况测试">实际情况测试</h1>
<p><em>特征码匹配</em>是单字通配符模糊匹配的应用场景之一</p>
<p>这里使用C#实现的<em>特征码匹配</em>对<code>GTAV</code>进程主模块内存进行搜索</p>
<p>测试环境：主串长度：将近8000万，Debug模式</p>
<h3 id="朴素算法暴力匹配">朴素算法（暴力匹配）</h3>
<img data-src="/2021/02/23/fuzzy-matching-algorithm-supporting-wildcard-based-on-Sunday/BF.png" class="">
<h3 id="sunday算法">Sunday算法</h3>
<img data-src="/2021/02/23/fuzzy-matching-algorithm-supporting-wildcard-based-on-Sunday/Sunday.png" class="">
<h3 id="总结">总结</h3>
<img data-src="/2021/02/23/fuzzy-matching-algorithm-supporting-wildcard-based-on-Sunday/time-consuming-chart.png" class="">
<img data-src="/2021/02/23/fuzzy-matching-algorithm-supporting-wildcard-based-on-Sunday/count-chart.png" class="">
<p>根据以上测试用例，可以看出。在<em>特征码匹配</em>的实际应用中，Sunday算法拥有极高的性能优势</p>
<ul>
<li>耗时：Sunday算法比朴素算法快了3-4倍</li>
<li>对比次数：Sunday算法比朴素算法减少了4-6倍</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>字符串匹配算法</tag>
        <tag>Sunday</tag>
        <tag>模糊匹配算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2021腾讯游戏安全技术竞赛 决赛PC客户端writeup</title>
    <url>/2021/04/22/gslab-ctf-finals-pc-writeup/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>最近忙了一些琐碎的事情，这两天又有闲功夫了，发现<a href="https://gslab.qq.com/html/competition/2021/index.htm">2021安全技术竞赛</a>决赛赛题出来了，而且比赛都结束了....</p>
<p>虽然赛事已经结束，但题目还是能做。既然闲下来就继续做做，写个writeup吧。</p>
<p><a href="https://gslab.qq.com/html/competition/2021/doc/PC%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%B9%E5%90%91%E5%86%B3%E8%B5%9B%E8%B5%9B%E9%A2%98.zip">PC决赛赛题下载</a></p>
<a id="more"></a>
<h1 id="赛题">赛题</h1>
<h3 id="说明">说明：</h3>
<ol type="1">
<li>shootgame是一个游戏，hack.exe是游戏shootergame的一个外挂程序。</li>
<li>运行shootgame游戏，运行hack.exe，成功执行外挂功能并分析外挂实现过程。</li>
</ol>
<h3 id="目标">目标：</h3>
<ol type="1">
<li>成功执行hack功能，给出外挂执行成功的flag</li>
<li>实现与hack.exe外挂功能相同，但原理不同的程序</li>
</ol>
<p>很有意思的游戏外挂方向，算是我比较擅长的领域</p>
<p>先打开游戏试试，跑一下hack.exe，发现一闪而过，并没有执行外挂功能 看了一下无壳，所以直接拖入IDA分析</p>
<h1 id="分析hack.exe">分析hack.exe</h1>
<p>main函数里就是整个外挂程序的执行流程，先大体看一下流程</p>
<h2 id="程序运行流程">程序运行流程</h2>
<h3 id="一.-程序先解密了字符串得到文件名hack.dat并读取了这个文件">一. 程序先解密了字符串，得到文件名hack.dat，并读取了这个文件</h3>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/step1.png" class="">
<figure class="highlight python"><figcaption><span>FileName解密</span></figcaption><table><tr><td class="code"><pre><span class="line">data = [<span class="number">0x06</span>, <span class="number">0x0E</span>, <span class="number">0x13</span>, <span class="number">0x1A</span>, <span class="number">0x5C</span>, <span class="number">0x17</span>, <span class="number">0x15</span>, <span class="number">0x1</span>]</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">    file_name += <span class="built_in">chr</span>(data[i] ^ i + <span class="number">110</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(file_name)</span><br></pre></td></tr></table></figure>
<p>这也解释了，直接打开外挂为什么会一闪而过</p>
<h3 id="二.-程序从hack.dat里解密出游戏进程名并打开游戏进程">二. 程序从hack.dat里解密出游戏进程名，并打开游戏进程</h3>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/step2.png" class="">
<p>decrypt函数解密出hack.dat的明文，通过下标构造出进程名，然后用<code>CreateToolhelp32Snapshot</code>和<code>Process32First</code>遍历进程，找到后打开进程。</p>
<p>代码中有一个for循环目前不太清楚是干嘛的、decrypt函数的解密算法也先放放。先继续往下看</p>
<h3 id="三.-程序开始构造flag并检查hack.dat的内容">三. 程序开始构造flag，并检查hack.dat的内容</h3>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/step3.png" class="">
<ol type="1">
<li>第一个循环用于构造flag，脚本如下（与解密FileName的算法一致）</li>
</ol>
<figure class="highlight python"><figcaption><span>flag构造</span></figcaption><table><tr><td class="code"><pre><span class="line">data = [<span class="number">92</span>, <span class="number">61</span>, <span class="number">35</span>, <span class="number">35</span>, <span class="number">26</span>, <span class="number">1</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">25</span>, <span class="number">32</span>, </span><br><span class="line"><span class="number">12</span>, <span class="number">53</span>, <span class="number">31</span>, <span class="number">55</span>, <span class="number">14</span>, <span class="number">55</span>, <span class="number">61</span>, <span class="number">44</span>, <span class="number">236</span>, <span class="number">213</span>, <span class="number">235</span>, </span><br><span class="line"><span class="number">241</span>, <span class="number">225</span>, <span class="number">255</span>, <span class="number">232</span>, <span class="number">245</span>, <span class="number">252</span>, <span class="number">241</span>, <span class="number">164</span>, <span class="number">228</span>, </span><br><span class="line"><span class="number">233</span>, <span class="number">193</span>, <span class="number">246</span>, <span class="number">250</span>, <span class="number">245</span>, <span class="number">249</span>, <span class="number">235</span>, <span class="number">234</span>, <span class="number">213</span>, </span><br><span class="line"><span class="number">226</span>, <span class="number">244</span>, <span class="number">231</span>, <span class="number">219</span>, <span class="number">214</span>, <span class="number">192</span>, <span class="number">234</span>, <span class="number">172</span>, <span class="number">233</span>, </span><br><span class="line"><span class="number">237</span>, <span class="number">204</span>, <span class="number">151</span>, <span class="number">236</span>, <span class="number">248</span>, <span class="number">218</span>, <span class="number">242</span>, <span class="number">193</span>, <span class="number">233</span>, </span><br><span class="line"><span class="number">242</span>, <span class="number">199</span>, <span class="number">236</span>, <span class="number">146</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(data[i] ^ i + <span class="number">110</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>第二个循环用于检查flag与hack.dat明文是否一致</li>
<li>如果一致，就解密出<code>flag%s</code>（此处省略解密脚本，与解密FileName的算法一致），调用<code>printf</code>输出flag</li>
</ol>
<h3 id="四.-注入dll">四. 注入DLL</h3>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/step4.png" class="">
<ol type="1">
<li>解密DLL数据</li>
<li>远程申请内存，用于放DLL</li>
<li>解密ntdll.dll，以及各种DLL注入需要用到的函数（解密算法还是和上文一样，函数很多，不一一展示了）</li>
</ol>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/step4-1.png" class="">
<ol start="4" type="1">
<li>使用<code>WriteProcessMemory</code>远程写入DLL内容、执行dll的执行器</li>
</ol>
<p>到这里，就能解释上文步骤二中的for是用来干嘛的了，是用来计算dll执行器的shellcode的长度</p>
<ol start="5" type="1">
<li>使用<code>CreateRemoteThreadEx</code>创建远程线程执行DLL，实现外挂功能</li>
</ol>
<h2 id="decrypt函数分析">decrypt函数分析</h2>
<p>hack.exe中有两处调用了decrypt函数，分别是: 1. hack.dat文件的解密 2. DLL数据的解密</p>
<p>由于上文已经知道了hack.dat解密出来的明文会与flag做对比。所以我们只需要分析decrypt函数的加密算法就可以得到hack.dat文件，也就能正常启动外挂了，顺便也可以dump出DLL文件</p>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/decrypt.png" class="">
<p>decrypt函数是经过SSE指令集优化后的解密函数。</p>
<p>利用SSE指令集，可以实现一个CPU指令操作16byte的数据，所以此函数SSE部分每次循环解密64byte的数据。 当解密到不足64byte时候（或本身就不足64byte），就使用常规，一byte一byte的解密 解密算法如图已经分析的很清楚了，下面上解密脚本，将flag反向输出成hack.dat</p>
<figure class="highlight python"><figcaption><span>输出hack.dat</span></figcaption><table><tr><td class="code"><pre><span class="line">flag = <span class="string">&#x27;2RSRhrofoWtLeLrJCSlTireznrtx.oeLxuehyyAwbpCOZq0tsS7MZyVdOUoE8&#x27;</span></span><br><span class="line"></span><br><span class="line">data = [<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> flag]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">    data[i] = (data[i] + <span class="number">0x13</span>) ^ <span class="number">0x3F</span></span><br><span class="line">    </span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;hack.dat&quot;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">fp.write(<span class="built_in">bytes</span>(data))</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure>
<p>把输出的hack.dat放在hack.exe目录下，运行hack.exe</p>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/flag.png" class="">
<p>成功输出flag</p>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/feature.png" class="">
<p>成功执行外挂功能，试了一下，鼠标右键可以自瞄</p>
<h2 id="dump外挂dll">Dump外挂DLL</h2>
<p>由于已经搞懂了decrypt函数的算法，将DLL给dump出来就很简单了，既可以动态调试、也可以静态的使用IDAPython脚本解密后输出</p>
<p>我这次使用脚本</p>
<figure class="highlight python"><figcaption><span>dump DLL</span></figcaption><table><tr><td class="code"><pre><span class="line">start_addr = <span class="number">0x14001DA40</span></span><br><span class="line"><span class="built_in">len</span> = <span class="number">0xFA00</span></span><br><span class="line">data = ida_bytes.get_bytes(start_addr, <span class="built_in">len</span>)</span><br><span class="line">dll = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">    dll.append((data[i] ^ <span class="number">0x3F</span>) - <span class="number">0x13</span> &amp; <span class="number">0xFF</span>)</span><br><span class="line"></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;D:\\dump.dll&quot;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">fp.write(<span class="built_in">bytes</span>(dll))</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure>
<h2 id="小总结">小总结</h2>
<p>dump出来后，下面就可以分析外挂功能的具体实现</p>
<h1 id="分析dump.dll">分析dump.dll</h1>
<p>无壳，直接拖入IDA分析</p>
<h2 id="程序运行流程-1">程序运行流程</h2>
<p>DllMain创建了一个线程，线程里放着主流程</p>
<h3 id="一.-程序先获取游戏主模块初始化各种全局变量">一. 程序先获取游戏主模块，初始化各种全局变量</h3>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/base-ptr.png" class="">
<p>根据主模块+基址偏移，获得World指针、三维xyz转屏幕xy的函数地址、以及游戏tick函数地址等等</p>
<h2 id="二.-然后hooking游戏tick函数将自瞄功能实现在hook函数里">二. 然后Hooking游戏tick函数，将自瞄功能实现在Hook函数里</h2>
<p>64位inline Hook，这里应该用了某Hook库，比较复杂。原理是修改原函数入口，JMP到Hook函数里，也实现了蹦床，这里就不具体分析了，看一下Hook修改原函数入口的核心代码就行，如下图</p>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/hook.png" class="">
<h2 id="三.-最后实现自瞄功能">三. 最后实现自瞄功能</h2>
<p>这里是本DLL的重点，自瞄功能的实现又分为以下几个步骤</p>
<ol type="1">
<li>根据基址偏移获取<code>player_controller</code>对象</li>
</ol>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/player-controller.png" class="">
<ol start="2" type="1">
<li>判断鼠标右键是否按下，如果按下就调用<code>get_target</code>函数尝试匹配一个敌人</li>
</ol>
<p><code>get_target</code>函数分析如下</p>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/foreach-objs.png" class="">
<p>遍历对象数组，并排除自己。获取每个对象名字，并排除物品、武器等对象</p>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/get-target.png" class="">
<p>计算每个敌人与准心的距离，取距离准心最近的一个敌人返回</p>
<ol start="3" type="1">
<li>获取自己和敌人的坐标</li>
</ol>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/get-pos.png" class="">
<ol start="4" type="1">
<li>计算相对距离，求俯仰角和偏航角，然后将数据写入到玩家Carm里，实现自瞄</li>
</ol>
<img data-src="/2021/04/22/gslab-ctf-finals-pc-writeup/end.png" class="">
<h2 id="小总结-1">小总结</h2>
<p>自此大概就明白了此DLL是如何实现自瞄的了，属于传统的内部攻击</p>
<h1 id="实现与hack.exe外挂功能相同的程序">实现与hack.exe外挂功能相同的程序</h1>
<p>等有时间了再写...</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>IDA Pro</tag>
        <tag>x64dbg</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>2021腾讯游戏安全技术竞赛 初赛PC客户端writeup</title>
    <url>/2021/04/06/gslab-ctf-preliminaries-pc-writeup/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>昨天玩脉脉有老哥建议我可以玩玩CTF，确实可以试一试，搜了一下最近的CTF，正好腾讯有一个<a href="https://gslab.qq.com/html/competition/2021/index.htm">安全技术竞赛</a>。</p>
<p>虽然错过了报名时间，但<a href="https://gslab.qq.com/html/competition/2021/doc/PC%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%A2%98%E7%9B%AE.zip">PC初赛赛题</a>还是可以下载下来做的</p>
<p>分析了一上午，这里写一个简陋的writeup</p>
<a id="more"></a>
<h1 id="赛题">赛题</h1>
<h3 id="pe信息">PE信息</h3>
<p>32位，无壳，VC++，跑起来后发现有加载OpenGL动态库</p>
<h3 id="目标">目标</h3>
<p>程序中藏有一个以"flag"开头的字符串。要求找出该字符串</p>
<h3 id="简单描述">简单描述</h3>
<p>运行起来后</p>
<ul>
<li>渲染了一个箭头，并指向右上角</li>
<li>视角有限制，无法移出箭头的视野</li>
</ul>
<img data-src="/2021/04/06/gslab-ctf-preliminaries-pc-writeup/subject.png" class="">
<h1 id="做题过程">做题过程</h1>
<h3 id="尝试解锁视角">尝试解锁视角</h3>
<p>第一感觉这个箭头是提示，指向正确的flag。但视角被卡了，所以先试试解锁视角</p>
<p>视角是根据鼠标的移动来移动的，熟悉Windows消息机制的话，就知道先去找窗口注册的函数，那里有WndProc函数，负责处理各种消息，当然也包括鼠标消息</p>
<p>IDA载入，打开Structures视图，找到<code>WNDCLASSEXW</code>结构体，按下X找到绑定的WndProc函数。</p>
<p>然后继续找到对应的鼠标移动时间的处理函数，发现确实有限制</p>
<img data-src="/2021/04/06/gslab-ctf-preliminaries-pc-writeup/limit-code.png" class="">
<p>到x32dbg里，NOP掉对应的if</p>
<img data-src="/2021/04/06/gslab-ctf-preliminaries-pc-writeup/limit-asm.png" class="">
<p>OK，现在可以自由的转动视角了，但转了一圈也没发现flag，果然不可能这么简单，哈哈</p>
<p>但箭头右上角确实有一些奇怪的东西，貌似是一堆箱子组成的文字？这可能才是我们要的答案</p>
<img data-src="/2021/04/06/gslab-ctf-preliminaries-pc-writeup/without-limit.png" class="">
<h3 id="静态分析渲染流程">静态分析渲染流程</h3>
<p>无奈只能深入看一下OpenGL的代码细节了，之前没接触过OpenGL，顺便找了个教程对着学</p>
<ol type="1">
<li>设置顶点数据 <img data-src="/2021/04/06/gslab-ctf-preliminaries-pc-writeup/attrib-code.png" class=""></li>
</ol>
<p>一个立方体有6个面，每个面有2个三角形，所以需要2 * 3 * 6 = 36个顶点</p>
<ol start="2" type="1">
<li><p>设置贴图纹理 <img data-src="/2021/04/06/gslab-ctf-preliminaries-pc-writeup/pixele-code.png" class=""></p></li>
<li><p>设置projection、view、model 3个变换矩阵并绘制界面</p></li>
</ol>
<p>程序先设置好设置projection和view，而后使用循环设置model以及<code>glDrawArrays</code></p>
<p>综上所述，我猜测这里就是在循环的回执立方体，最终形成一个箭头的形状，包括之前看到的奇怪的东西</p>
<img data-src="/2021/04/06/gslab-ctf-preliminaries-pc-writeup/model-loop-code.png" class="">
<p>dword_466020和dword_46601C应该是记录了三维向量表的开头和结尾</p>
<h3 id="动态调试验证">动态调试验证</h3>
<p>到x32dbg里，我们找到渲染立方体的地方，下断</p>
<img data-src="/2021/04/06/gslab-ctf-preliminaries-pc-writeup/model-loop-asm.png" class="">
<p>重新运行程序，方便找到向量表的开头</p>
<img data-src="/2021/04/06/gslab-ctf-preliminaries-pc-writeup/matrix.png" class="">
<p>试试看清空数据，发现少了一些立方体</p>
<img data-src="/2021/04/06/gslab-ctf-preliminaries-pc-writeup/empty.png" class="">
<p>我们F4运行到循环外，发现数组长度0xBF1，也就是3057</p>
<img data-src="/2021/04/06/gslab-ctf-preliminaries-pc-writeup/loop-end-asm.png" class="">
<p>因为每次渲染会取xyz三个float，也就是说循环的增量是i+=3，3057/3 = 1019</p>
<p>也就是说一共有1019个立方体</p>
<p>我们把这些数据提取出来，然后编写个DX9程序绘制一下即可</p>
<img data-src="/2021/04/06/gslab-ctf-preliminaries-pc-writeup/flag.png" class="">
<h1 id="总结">总结</h1>
<p>难度不是很大，但还是需要点耐心的，特别是我这种不会OpenGL的</p>
<p>顺便也是学习了一些OpenGL相关知识吧，顶点、顶点缓冲对象、着色器、贴图纹理等等...</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>IDA Pro</tag>
        <tag>x64dbg</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>导入地址表（IAT）Hook</title>
    <url>/2021/03/05/iat-hook/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>在上一个Hook文章中，我利用C++虚函数的特性，实现了<a href="/2020/12/07/vmt-hook/">虚函数表钩子（VMT Hook）</a>。</p>
<p>VMT Hook实现起来简单，但使用范围有限。只能用来挂钩有虚函数的对象。</p>
<p>今天介绍一个适用范围相对更广一些的Hook技术，也就是导入地址表（IAT）Hook。</p>
<h1 id="什么是iat">什么是IAT?</h1>
<p>如果你熟悉程序编译的过程，你会知道链接分为两种： - 静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在程序被执行时，这些代码会被装入到该进程的虚拟地址空间 - 动态链接：代码被放到动态链接库中，在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间</p>
<p>而IAT（导入地址表）就是动态链接的实现方法。</p>
<a id="more"></a>
<p>PE标头包含许多数据表，其中包含有关可执行文件的不同信息。而IAT顾名思义，就是保存了外部的动态链接库中导出函数地址的表。</p>
<p>在运行时，操作系统解析导入表，尝试加载指定的dll并解析导入函数的地址。如果此过程失败，则程序将无法加载</p>
<img data-src="/2021/03/05/iat-hook/sys_err.png" class="">
<blockquote>
<p>上图提示，找不到VC++运行库</p>
</blockquote>
<h2 id="攻击方法">攻击方法</h2>
<p>我们可以用两种方法来攻击它： 1. 直接篡改可执行程序的文件（不推荐，因为如今大多数程序都有签名，大多数杀软会标记被篡改过的程序） 2. 在运行时注入代码并修改IAT</p>
<p>通过在运行时注入代码，我们可以避免在硬盘上留下痕迹。尽管仍然可能会被检测到，但与直接篡改文件相比，安全得多。</p>
<h1 id="实现">实现</h1>
<p>先从基础开始，先尝试Hook我们自己的进程IAT。用我们自己的函数覆盖<code>Kernel32!Sleep</code>的地址。</p>
<h2 id="定义框架">定义框架</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于RVA（相对虚拟地址）转VA（虚拟地址）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">rva_to_va</span><span class="params">(<span class="type">void</span>* base, <span class="type">ptrdiff_t</span> rva)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_pointer&lt;T&gt;::value, <span class="string">&quot;rva_to_va return type must be a pointer.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;T&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(base) + rva);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于保存原始函数的地址</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">sleep_t</span> = <span class="type">void</span>* (WINAPI*)(DWORD);</span><br><span class="line"><span class="type">sleep_t</span> original_sleep;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的钩子函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> WINAPI <span class="title">my_sleep</span><span class="params">(DWORD ms)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hook_iat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* module_name, <span class="type">const</span> <span class="type">char</span>* function_name, <span class="type">void</span>* hook_func, <span class="type">void</span>** original_func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* original_func;</span><br><span class="line">    <span class="built_in">hook_iat</span>(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="string">&quot;Sleep&quot;</span>, my_sleep, &amp;original_func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pe标头">PE标头</h2>
<p>MSDN上的<a href="https://docs.microsoft.com/zh-cn/windows/win32/debug/pe-format">PE格式</a>文档</p>
<p>本文假定你熟悉PE格式中的IAT部分。</p>
<p>我们要分析IAT，所以得在标头中定位IAT</p>
<p>首先得获得指向PE Header开头的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取DOS头指针</span></span><br><span class="line"><span class="keyword">auto</span> dos_header = <span class="built_in">reinterpret_cast</span>&lt;IMAGE_DOS_HEADER*&gt;(<span class="built_in">GetModuleHandle</span>(<span class="literal">nullptr</span>));</span><br><span class="line"><span class="comment">// 获取NT头指针</span></span><br><span class="line"><span class="keyword">auto</span> nt_header = <span class="built_in">rva_to_va</span>&lt;IMAGE_NT_HEADERS*&gt;(dos_header, dos_header-&gt;e_lfanew);</span><br><span class="line"><span class="comment">// 特判，保证获取到了有效的NT头指针</span></span><br><span class="line"><span class="keyword">if</span> (nt_header-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取导入描述符指针</span></span><br><span class="line"><span class="keyword">auto</span> import_descriptors = <span class="built_in">rva_to_va</span>&lt;IMAGE_IMPORT_DESCRIPTOR*&gt;(dos_header, </span><br><span class="line">    nt_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line"><span class="comment">// 循环解析导入描述符中的条目</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; import_descriptors[i].Characteristics != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 获得模块名，并输出</span></span><br><span class="line">    <span class="keyword">auto</span> dll_name = <span class="built_in">rva_to_va</span>&lt;<span class="type">char</span>*&gt;(dos_header, import_descriptors[i].Name);</span><br><span class="line">    std::cout &lt;&lt; dll_name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果编译并运行该代码，则会打印你的进程使用的所有导入模块（可能因编译器而异）: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KERNEL32.dll</span><br><span class="line">MSVCP140D.dll</span><br><span class="line">VCRUNTIME140D.dll</span><br><span class="line">ucrtbased.dll</span><br></pre></td></tr></table></figure></p>
<p>找到了所有模块后，就可以开始找函数了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; import_descriptors[i].Characteristics != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">auto</span> dll_name = <span class="built_in">rva_to_va</span>&lt;<span class="type">char</span>*&gt;(dos_header, import_descriptors[i].Name);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; dll_name &lt;&lt; <span class="string">&#x27;]&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!import_descriptors[i].FirstThunk || !import_descriptors[i].OriginalFirstThunk)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> thunk = <span class="built_in">rva_to_va</span>&lt;IMAGE_THUNK_DATA*&gt;(dos_header, import_descriptors[i].FirstThunk);</span><br><span class="line">    <span class="keyword">auto</span> original_thunk = <span class="built_in">rva_to_va</span>&lt;IMAGE_THUNK_DATA*&gt;(dos_header, import_descriptors[i].OriginalFirstThunk);</span><br><span class="line">    <span class="keyword">for</span> (; original_thunk-&gt;u1.Function; original_thunk++, thunk++) &#123;</span><br><span class="line">        <span class="comment">// 跳过通过序数导入的</span></span><br><span class="line">        <span class="keyword">if</span> (original_thunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> <span class="keyword">import</span> = <span class="built_in">rva_to_va</span>&lt;IMAGE_IMPORT_BY_NAME*&gt;(dos_header, original_thunk-&gt;u1.AddressOfData);</span><br><span class="line">        std::cout &lt;&lt; <span class="keyword">import</span>-&gt;Name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[KERNEL32.dll]</span><br><span class="line">GetModuleHandleW</span><br><span class="line">FreeLibrary</span><br><span class="line">VirtualQuery</span><br><span class="line">GetProcessHeap</span><br><span class="line">HeapFree</span><br><span class="line">HeapAlloc</span><br><span class="line">GetLastError</span><br><span class="line">GetStartupInfoW</span><br><span class="line">InitializeSListHead</span><br><span class="line">GetSystemTimeAsFileTime</span><br><span class="line">GetCurrentProcessId</span><br><span class="line">QueryPerformanceCounter</span><br><span class="line">IsProcessorFeaturePresent</span><br><span class="line">TerminateProcess</span><br><span class="line">GetCurrentProcess</span><br><span class="line">SetUnhandledExceptionFilter</span><br><span class="line">UnhandledExceptionFilter</span><br><span class="line">WideCharToMultiByte</span><br><span class="line">MultiByteToWideChar</span><br><span class="line">RaiseException</span><br><span class="line">IsDebuggerPresent</span><br><span class="line">GetCurrentThreadId</span><br><span class="line">GetProcAddress</span><br><span class="line">Sleep</span><br><span class="line">TerminateProcess</span><br><span class="line">TlsGetValue</span><br><span class="line">UnhandledExceptionFilter</span><br><span class="line">VirtualProtect</span><br><span class="line">VirtualQuery</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>OK，我们已经成功找到了对应模块的导入函数。下面就是通过修改导入表来实现IAT Hook</p>
<h2 id="实现iat-hook">实现IAT Hook</h2>
<p>修改IAT很简单，找到需要修改的函数后，使用<code>VirtualProtect</code>去除内存保护，写入新地址，然后再恢复内存保护</p>
<p>完整的Hook IAT函数： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hook_iat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* module_name, <span class="type">const</span> <span class="type">char</span>* function_name, <span class="type">void</span>* hook_func, <span class="type">void</span>** original_func)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取DOS头指针</span></span><br><span class="line">    <span class="keyword">auto</span> dos_header = <span class="built_in">reinterpret_cast</span>&lt;IMAGE_DOS_HEADER*&gt;(<span class="built_in">GetModuleHandle</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="comment">// 获取NT头指针</span></span><br><span class="line">    <span class="keyword">auto</span> nt_header = <span class="built_in">rva_to_va</span>&lt;IMAGE_NT_HEADERS*&gt;(dos_header, dos_header-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 特判，保证获取到了有效的NT头指针</span></span><br><span class="line">    <span class="keyword">if</span> (nt_header-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取导入描述符指针</span></span><br><span class="line">    <span class="keyword">auto</span> import_descriptors = <span class="built_in">rva_to_va</span>&lt;IMAGE_IMPORT_DESCRIPTOR*&gt;(dos_header,</span><br><span class="line">        nt_header-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环解析导入描述符中的条目</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; import_descriptors[i].Characteristics != <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> dll_name = <span class="built_in">rva_to_va</span>&lt;<span class="type">char</span>*&gt;(dos_header, import_descriptors[i].Name);</span><br><span class="line">        <span class="comment">// 如果不是我们要找的模块，就跳过</span></span><br><span class="line">        <span class="keyword">if</span> (_strcmpi(dll_name, module_name) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (!import_descriptors[i].FirstThunk || !import_descriptors[i].OriginalFirstThunk)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">auto</span> thunk = <span class="built_in">rva_to_va</span>&lt;IMAGE_THUNK_DATA*&gt;(dos_header, import_descriptors[i].FirstThunk);</span><br><span class="line">        <span class="keyword">auto</span> original_thunk = <span class="built_in">rva_to_va</span>&lt;IMAGE_THUNK_DATA*&gt;(dos_header, import_descriptors[i].OriginalFirstThunk);</span><br><span class="line">        <span class="keyword">for</span> (; original_thunk-&gt;u1.Function; original_thunk++, thunk++) &#123;</span><br><span class="line">            <span class="comment">// 跳过通过序数导入的</span></span><br><span class="line">            <span class="keyword">if</span> (original_thunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">auto</span> <span class="keyword">import</span> = <span class="built_in">rva_to_va</span>&lt;IMAGE_IMPORT_BY_NAME*&gt;(dos_header, original_thunk-&gt;u1.AddressOfData);</span><br><span class="line">            <span class="comment">// 如果不是我们要找的函数，就跳过</span></span><br><span class="line">            <span class="keyword">if</span> (_strcmpi(function_name, <span class="keyword">import</span>-&gt;Name) != <span class="number">0</span>)</span><br><span class="line">			    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到了我们要Hook的函数</span></span><br><span class="line">            <span class="comment">// 先将内存保护改为可写入</span></span><br><span class="line">            MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">            <span class="built_in">VirtualQuery</span>(thunk, &amp;mbi, <span class="built_in">sizeof</span>(mbi));</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &amp;mbi.Protect))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存原函数地址</span></span><br><span class="line">            *original_func = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(thunk-&gt;u1.Function);</span><br><span class="line">            <span class="comment">// 将Hook函数地址覆盖上去</span></span><br><span class="line">            thunk-&gt;u1.Function = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(hook_func);</span><br><span class="line">            <span class="comment">// 恢复内存保护</span></span><br><span class="line">            DWORD _;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">VirtualProtect</span>(mbi.BaseAddress, mbi.RegionSize, mbi.Protect, &amp;_))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 现在我们就可以在主函数中调用它了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新钩子函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> WINAPI <span class="title">my_sleep</span><span class="params">(DWORD ms)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[?] Hooked Sleep Function Called!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sleeping for: 0x&quot;</span> &lt;&lt; ms &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 调用原函数</span></span><br><span class="line">    <span class="built_in">original_sleep</span>(ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* original_func;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;IAT Hook Example by AmazingPP\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">hook_iat</span>(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="string">&quot;Sleep&quot;</span>, my_sleep, &amp;original_func)) &#123;</span><br><span class="line">	    std::cout &lt;&lt; <span class="string">&quot;[-] Hooking failed! error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; std::hex &lt;&lt; </span><br><span class="line">            <span class="string">&quot;[?] Old Address: 0x&quot;</span> &lt;&lt; original_func &lt;&lt; std::endl &lt;&lt; </span><br><span class="line">            <span class="string">&quot;[+] New Address: 0x&quot;</span> &lt;&lt; my_sleep &lt;&lt; std::endl;</span><br><span class="line">        original_sleep = <span class="built_in">static_cast</span>&lt;<span class="type">sleep_t</span>&gt;(original_func);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">0x10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<img data-src="/2021/03/05/iat-hook/final_out.png" class="">
<p>上面的例子是简单的面向过程封装。使用上述代码，你可以Hook任何Win32 API。 你也可以把代码构建成DLL，任何将其注入到需要攻击的进程中。</p>
<h1 id="总结">总结</h1>
<ul>
<li><strong>执行速度:10</strong></li>
<li><strong>编写难度:3</strong></li>
<li><strong>检测率:5</strong></li>
</ul>
<p>IAT Hook基于PE文件在Windows上的工作方式。 基本思想依旧是函数指针的替换，将导入函数重定向。 对于简单的API挂钩很方便，而且没有性能损失 且可运用于DirectX挂钩，实现内部绘制层，进而实现透视等功能</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>逆向</tag>
        <tag>PE</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>解决IDA的call analysis failed调用分析失败</title>
    <url>/2020/12/30/ida-call-analysis-failed/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>好基友<a href="https://github.com/AmazingDM">AmazingDM</a>几天前给我发来一个程序，希望我帮忙分析一下key的加密算法</p>
<p>但我用IDA加载后发现无法在main函数使用F5，警告如下： <img data-src="/2020/12/30/ida-call-analysis-failed/warning.png" class=""></p>
<a id="more"></a>
<h1 id="了解错误">了解错误</h1>
<blockquote>
<p>根据<a href="https://www.hex-rays.com/products/decompiler/manual/failures.shtml#11">IDA官网</a>对call analysis failed的解释，出现这种问题的原因可能分两种： 1. 反编译器无法确定调用约定（the decompiler could not determine the calling convention） 2. 反编译器无法确定参数个数和类型</p>
</blockquote>
<p>我们G到<code>4907EB</code>的位置</p>
<img data-src="/2020/12/30/ida-call-analysis-failed/call_eax.png" class="">
<p>发现这个call是一个寄存器形式的call，<code>EAX=EBP-120</code>，然后调用<code>EAX</code>，参数是<code>0</code></p>
<p>这里就能看出问题的根本原因了</p>
<p>是因为<code>EBP-120</code>不是一个常量，所以<strong>IDA没法分析出<code>EAX</code>的地址</strong></p>
<p>这个时候只能用到x64dbg了，看看这个<code>EAX</code>里到底是什么</p>
<h1 id="动态调试">动态调试</h1>
<p>由于是32位应用，这里使用x32dbg</p>
<ol type="1">
<li>打开软件并配置命令行，自动断到入口点</li>
<li>Ctrl+G，输入<code>4907EB</code></li>
<li>F4运行到这个call</li>
</ol>
<p>发现<code>EAX</code>是<code>msvcrt.time</code></p>
<img data-src="/2020/12/30/ida-call-analysis-failed/eax_func.png" class="">
<p>也就是C语言库函数<code>time</code>，这也解释了为什么调用时参数是0（空指针）</p>
<h1 id="静态分析">静态分析</h1>
<p>我们回到IDA，打开导入函数表，搜索<code>time</code>这个函数</p>
<img data-src="/2020/12/30/ida-call-analysis-failed/iat_time.png" class="">
<p>确实有这个函数，我们双击进去。按X，查看<code>time</code>的交叉引用</p>
<img data-src="/2020/12/30/ida-call-analysis-failed/xrefs_time.png" class="">
<p>这个函数在main函数里只使用过一次，我们双击过去看汇编</p>
<img data-src="/2020/12/30/ida-call-analysis-failed/save_time.png" class="">
<p>重点就在红框的代码里，先将<code>time</code>保存在了<code>EAX</code>里，随后又将<code>EAX</code>保存在了<code>EBP-120</code>里</p>
<p>原来<code>4907EB</code>那调用的<code>EBP-120</code>就是<code>time</code>。</p>
<p>这与之前动态调试的结果一致</p>
<h1 id="修复">修复</h1>
<p>选中<code>mov eax, [ebp+var_120]</code>，按下<code>Ctrl+Alt+K</code>，使用Keypatch插件修改汇编</p>
<img data-src="/2020/12/30/ida-call-analysis-failed/keypatch.png" class="">
<p>修改成<code>mov eax, 4D2574</code>，也就是导入函数<code>time</code>的地址</p>
<img data-src="/2020/12/30/ida-call-analysis-failed/fixed.png" class="">
<p>可以看到虽然代码还是<code>call eax</code>，但这时IDA已经识别到<code>EAX</code>是<code>time</code>了，并自己加上了注释</p>
<p>按照上述方法修复所有地方，按下F5，成功输出伪代码~</p>
<img data-src="/2020/12/30/ida-call-analysis-failed/f5.png" class="">
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>IDA Pro</tag>
        <tag>x64dbg</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP和Sunday算法实现 strStr() 函数</title>
    <url>/2021/02/08/implementation-of-strstr-with-KMP-and-BMHS-algorithm/</url>
    <content><![CDATA[<h1 id="实现-strstr-函数"><a href="https://leetcode-cn.com/problems/implement-strstr">实现 strStr() 函数</a></h1>
<p>给定一个 <code>haystack</code> 字符串和一个 <code>needle</code> 字符串，在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p>
<h3 id="示例-1">示例 1:</h3>
<blockquote>
<p>输入: haystack = "hello", needle = "ll" 输出: 2</p>
</blockquote>
<h3 id="示例-2">示例 2:</h3>
<blockquote>
<p>输入: haystack = "aaaaa", needle = "bba" 输出: -1</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p><em>注：本文算法复杂度中的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="2.378ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 1051 683" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D440"></use></g></g></g></svg></mjx-container>是模式串的长度，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="2.009ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 888 683" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D441"></use></g></g></g></svg></mjx-container>是主串的长度，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="1.695ex" height="1.538ex" role="img" focusable="false" viewBox="0 -680 749 680" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D439"></use></g></g></g></svg></mjx-container>是<code>SIMD</code>操作引入的常数。</em></p>
</blockquote>
<h1 id="库函数解法">库函数解法</h1>
<p>谁不爱库函数呢😋</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.<span class="built_in">find</span>(needle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析">复杂度分析</h2>
<p>经过查阅资料得知，C++下的<code>string::find</code>是<code>SIMD</code>指令集优化后的朴素算法<a href="#refer"><sup>[1]</sup></a><a href="#refer"><sup>[2]</sup></a></p>
<ul>
<li>预处理时间复杂度：<em>无</em></li>
<li>匹配时间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="7.584ex" height="2.765ex" role="img" focusable="false" viewBox="0 -877 3352.1 1222" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-2-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-2-TEX-I-1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mfrac" transform="translate(1152, 0)"><g data-mml-node="mrow" transform="translate(220, 394) scale(0.707)"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D440"></use></g><g data-mml-node="mi" transform="translate(1051, 0)"><use xlink:href="#MJX-2-TEX-I-1D441"></use></g></g><g data-mml-node="mi" transform="translate(640.7, -345) scale(0.707)"><use xlink:href="#MJX-2-TEX-I-1D439"></use></g><rect width="1571.1" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(2963.1, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
<li>空间复杂度：<em>无</em></li>
</ul>
<h1 id="kmp解法">KMP解法</h1>
<p>看了<code>Carl</code>大师兄的KMP算法解读，终于“入门”了KMP🤪，这边强烈推荐下：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1PD4y1o7nd">帮你把KMP算法学个通透！（理论篇）B站视频</a></li>
<li><a href="https://www.bilibili.com/video/BV1M5411j7Xx">帮你把KMP算法学个通透！（代码篇）B站视频</a></li>
</ul>
<p>KMP算法的具体理论相对比较复杂，大家可以百度，这里提一下我的理解</p>
<p>根据我的理解，KMP算法的核心就在于求得<strong>前缀表</strong>，体现在代码上就是<strong>构造模式串匹配字符指针的转移数组</strong>，即 <code>next</code> 数组</p>
<p>个人感觉求 <code>next</code> 数组的过程有点像动态规划</p>
<p>下面由菜鸡为大家手撕KMP</p>
<h2 id="实现">实现</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h_len = haystack.<span class="built_in">size</span>(), n_len = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n_len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> next = <span class="built_in">getNext</span>(needle); <span class="comment">// 预处理</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// j 模式串指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h_len; ++i) &#123; <span class="comment">// i 主串指针</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) <span class="comment">// 不匹配</span></span><br><span class="line">                j = next[j - <span class="number">1</span>]; <span class="comment">// j 回溯到之前匹配的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) <span class="comment">// 匹配</span></span><br><span class="line">                ++j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j == n_len) <span class="comment">// j 指针走到了模式串的末尾（即在主串中找到了模式串）</span></span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造前缀表</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNext</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j; <span class="comment">// 第一个字符的前缀长度必定是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// i 从1开始</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) <span class="comment">// 前后缀不同</span></span><br><span class="line">                j = next[j - <span class="number">1</span>]; <span class="comment">// 向前回溯</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) <span class="comment">// 前后缀相同 </span></span><br><span class="line">                ++j;</span><br><span class="line"></span><br><span class="line">            next[i] = j; <span class="comment">// 保存前缀长度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析-1">复杂度分析</h2>
<ul>
<li>预处理时间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.864ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2592 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-2-TEX-I-1D440"></use></g><g data-mml-node="mo" transform="translate(2203, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
<li>匹配时间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2429 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-2-TEX-I-1D441"></use></g><g data-mml-node="mo" transform="translate(2040, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
<li>空间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.864ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2592 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-2-TEX-I-1D440"></use></g><g data-mml-node="mo" transform="translate(2203, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
</ul>
<h1 id="sunday解法">Sunday解法</h1>
<p>Sunday算法是BMH算法的变种，写法比BMH更简单，思想比KMP简单，且在实际情况下，都比BMH和KMP有更好的效率<a href="#refer"><sup>[3]</sup></a>。</p>
<p>这种又简单效率又高的算法，当然要学一学了，Sunday的思想在于如何在遇到不匹配的字符时<strong>跳过尽可能多的字符</strong>，以减少对比次数。</p>
<p>下面由菜鸡表演</p>
<h2 id="实现-1">实现</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h_len = haystack.<span class="built_in">size</span>(), n_len = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n_len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 构建偏移表</span></span><br><span class="line">        <span class="type">int</span> shift[<span class="number">0xFF</span> + <span class="number">1</span>]&#123;&#125;;</span><br><span class="line">        <span class="comment">// 必须正向遍历，因为如果有重复的字母</span></span><br><span class="line">        <span class="comment">// 需要匹配索引最大的(移动步长最短)</span></span><br><span class="line">        <span class="comment">// 防止跳的过远遗漏数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_len; ++i) &#123;</span><br><span class="line">            shift[needle[i]] = n_len - i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= h_len - n_len;) &#123; <span class="comment">// i 主串指针</span></span><br><span class="line">            <span class="type">bool</span> found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n_len; ++j) &#123; <span class="comment">// j 模式串指针</span></span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">                    found = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found) <span class="comment">// 匹配，返回索引</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 不匹配，判断参与匹配的末尾字符的下一位是否在模式串中存在</span></span><br><span class="line">            <span class="type">int</span> step = shift[haystack[i + n_len]];</span><br><span class="line">            <span class="keyword">if</span> (step &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                i += step; <span class="comment">// 出现在模式串中，按偏移量跳过</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i += n_len + <span class="number">1</span>; <span class="comment">// 没出现在模式串中，跳过模式串长度 + 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析-2">复杂度分析</h2>
<ul>
<li>预处理时间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.864ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2592 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-2-TEX-I-1D440"></use></g><g data-mml-node="mo" transform="translate(2203, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
<li>匹配时间复杂度：
<ul>
<li>平均：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2429 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-2-TEX-I-1D441"></use></g><g data-mml-node="mo" transform="translate(2040, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
<li>最好：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex" xmlns="http://www.w3.org/2000/svg" width="6.163ex" height="2.765ex" role="img" focusable="false" viewBox="0 -877 2724.2 1222" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-1-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mfrac" transform="translate(1152, 0)"><g data-mml-node="mi" transform="translate(277.6, 394) scale(0.707)"><use xlink:href="#MJX-1-TEX-I-1D441"></use></g><g data-mml-node="mi" transform="translate(220, -345) scale(0.707)"><use xlink:href="#MJX-1-TEX-I-1D440"></use></g><rect width="943.2" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(2335.2, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
<li>最差：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.873ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3480 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-1-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-1-TEX-I-1D440"></use></g><g data-mml-node="mi" transform="translate(2203, 0)"><use xlink:href="#MJX-1-TEX-I-1D441"></use></g><g data-mml-node="mo" transform="translate(3091, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
</ul></li>
<li>空间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.864ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2592 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-1-TEX-I-1D440"></use></g><g data-mml-node="mo" transform="translate(2203, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container></li>
</ul>
<div id="refer">

</div>
<h1 id="总结">总结</h1>
<h2 id="共同的核心思想">共同的核心思想</h2>
<p>无论是KMP和Sunday算法， <strong>减少重复匹配</strong> 都是核心思想，且都是通过<em>跳转</em>来完成的</p>
<h2 id="思想">思想</h2>
<ul>
<li><p>KMP通过前缀表，也就是<code>next</code>数组，告诉<code>j</code>，如果匹配失败的话应该跳转到<code>next[j]</code>位置进行匹配，<code>next</code>数组能保证的是<code>next[j]</code>前面的位置已经匹配上了</p></li>
<li><p>Sunday则是通过偏移表，在匹配失败时，确定需要移动的位数，然后让<code>i</code>去位移</p></li>
</ul>
<h2 id="实用意义">实用意义</h2>
<ul>
<li>KMP在实际的字符串匹配需求中已经被抛弃，但KMP的思想是值得学习的。</li>
<li>Sunday在现实中的实用意义很大，因为其效率很高（发明者宣称在实际场景下，比BM快大约4.5倍）。但缺点也很明显，比如遇到<code>"aaaaaaaaaaaab","ab"</code>，就会退化成朴素算法，时间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.873ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3480 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-1-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-1-TEX-I-1D440"></use></g><g data-mml-node="mi" transform="translate(2203, 0)"><use xlink:href="#MJX-1-TEX-I-1D441"></use></g><g data-mml-node="mo" transform="translate(3091, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container> ，不过现实中极少有这么极端的情况。</li>
</ul>
<h1 id="埋坑">埋坑</h1>
<p>实现一个<a href="/2021/02/23/fuzzy-matching-algorithm-supporting-wildcard-based-on-Sunday/">支持单字通配符的Sunday模糊匹配算法</a></p>
<h1 id="引用">引用</h1>
<ol type="1">
<li>Kumar, Aditya. <a href="https://reviews.llvm.org/D27068">"libc++: Improve string::find algorithm"</a></li>
<li>Kumar, Aditya. <a href="https://gcc.gnu.org/legacy-ml/libstdc++/2017-01/msg00039.html">"libstdc++: Improve string::find algorithm"</a></li>
<li>Hume; Sunday (1991). <a href="https://www.semanticscholar.org/paper/Fast-string-searching-Hume-Sunday/d9912ea262986794e29e3f15e5f8930d42f2ced4">"Fast String Searching"</a></li>
<li>Wiki. <a href="https://en.wikipedia.org/wiki/String-searching_algorithm">"String-searching algorithm"</a></li>
</ol>
<h1 id="更改">更改</h1>
<ul>
<li>[2021-02-23] 更新Sunday算法代码，将偏移表从<code>unordered_map</code>改为原生数组，<code>unordered_map</code>过重，直接用数组当做特殊的哈希表即可</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>字符串匹配算法</tag>
        <tag>Sunday</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2021春招面试经验</title>
    <url>/2021/03/19/interview-experience-of-2021-spring-recruitment/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>参加了一个星期的面试，终于定下来了，把面试经验记录一下（全凭回忆，问题可能不全）</p>
<a id="more"></a>
<h1 id="qt开发未发offer">Qt开发（未发Offer）</h1>
<ol type="1">
<li>你的线程池是怎么实现的</li>
<li>你的线程池有什么地方可以改进的</li>
<li>简单讲一讲epoll</li>
<li>你对Qt有多少了解（不怎么了解，只在大学用Qt做过课程作业）</li>
<li>C++与C的区别</li>
<li>虚函数的原理</li>
<li>C++类对象初始化的顺序？</li>
<li>那析构的顺序呢？</li>
</ol>
<p>技术面试自我感觉答的还可以，过了后，经理就一直在说你不会Qt，要学习啥的，反正就在强调自学能力和用人成本....说的我不耐烦了，他看我不咋想听就结束面试了</p>
<h1 id="初创公司java实习已发offer">初创公司Java实习（已发Offer）</h1>
<ol type="1">
<li>自我介绍</li>
<li>你以前用过IoC框架，那么请你解释一下IoC和DI</li>
<li>你以前用过RabbitMQ，请你描述一下消息队列的应用场景</li>
<li>RabbitMQ的3大模式 （这里只说出来一种，2年前用的，忘了）</li>
<li>请说一下浏览器访问一个网页的全过程 （基本细节都说到了，面试官说可以把DNS解析那块再说详细点）</li>
<li>ArrayList和LinkedList的区别（Java八股文，完全不会，和面试官解释我的Java只停留在最最最基础后，表示没关系）</li>
<li>说一说数组和链表的区别</li>
<li>你知道哪些数据结构</li>
<li>手写代码，统计左右括号合法匹配的个数 （用栈，很简单）</li>
<li>反问环节</li>
</ol>
<p>最好的一次面试体验，面试官全程面带微笑，也会鼓励你去思考，鼓励你尝试手写代码。也是唯一一家面试官主动给我倒开水的，让我感受到了无比的尊重。</p>
<h1 id="医疗器械c开发-已发offer">医疗器械C++开发 （已发Offer）</h1>
<ol type="1">
<li>自我介绍</li>
</ol>
<p>基本就一直在聊天，聊对医疗器械的看法，对业务的看法，对公司的看法，没有问技术</p>
<h1 id="通信协议c开发-已发offer">通信协议C++开发 （已发Offer）</h1>
<p>进来直接写笔试题</p>
<ol type="1">
<li>你觉得<code>if (n == 1)</code>和<code>if (1 == n)</code>哪种更好 （当时没太理解，但我平时写代码大多用第一种。后来说第二种可以防止失误写成<code>if (n = 1)</code>...确实有点道理）</li>
<li>以下代码有什么问题 （代码不贴了 1. malloc没有free 2. malloc返回值是void*需要显式类型转换）</li>
<li>指针和引用的区别</li>
<li>什么是内存泄漏？如何避免</li>
<li>如果遇到了内存泄漏，如何解决</li>
<li>什么是虚函数？</li>
<li>什么情况下会调用复制构造函数（3种，当时写出来2种。后来一想，参数值传递时也是会调用复制构造函数的）</li>
<li>delete和delete[]的区别</li>
<li>析构函数为什么需要定义成虚函数？</li>
<li>浅拷贝和深拷贝的区别</li>
</ol>
<p>写完后和经理聊，以及一些反问环节</p>
<h1 id="模拟仿真c开发-已发offer">模拟仿真C++开发 （已发Offer）</h1>
<p>先填个人信息，然后两个面试官技术面</p>
<ol type="1">
<li>自我介绍</li>
<li>C++和C#的区别</li>
<li>托管代码和非托管代码的优劣 （这个没答好，当时说托管代码没啥特别的好处，面试官让我回去再思考思考，哈哈）</li>
<li>编译时多态和运行时多态的区别</li>
<li>请细致的说一下虚函数和纯虚函数（这里聊的特别深）</li>
<li>虚函数有性能损失吗，为什么？</li>
<li>了解哪些设计模式</li>
<li>单例模式有哪些实现方式</li>
<li>单例模式里的懒汉模式，饿汉模式有什么区别？分别有什么应用场景？</li>
<li>请细致说一下抽象工厂模式的实现方式，有什么应用场景</li>
<li>智能指针是什么？</li>
<li>请你详细对比一下shared_ptr、unique_ptr和weak_ptr的区别</li>
<li>shared_ptr的原理和weak_ptr的原理（这里weak_ptr的原理不知道）</li>
<li>vector和list的区别，vector是如何扩容的？扩容时会发生什么？</li>
<li>你知道哪些数据结构</li>
<li>如何判断链表有没有环（快慢指针）</li>
<li>你知道哪些STL容器</li>
<li>set和unordered_set的区别是什么？</li>
<li>set的顺序是什么样的？（不知道，哈哈）</li>
<li>排序算法了解哪些？时间复杂度分别是多少？</li>
<li>快速排序的原理是什么？时间复杂度什么时候最差，什么时候最好？</li>
<li>TCP和UDP的区别？三次握手和四次挥手了解吗？</li>
<li>什么是TCP粘包？如何解决？（这个不知道，网络基础还是太差了）</li>
<li>select、poll、epoll的区别？你为什么选择epoll？</li>
<li>epoll一定能保证性能是最好的嘛？</li>
<li>请你设计一个select、epoll融合的多路IO转接</li>
<li>多线程了解多少，多线程之间如何同步？</li>
<li>信号量有几个状态（不清楚，信号量用得少。平时互斥锁和条件变量用的比较多）</li>
<li>对Qt有多少了解？（不怎么了解，只在大学用Qt做过课程作业）</li>
<li>反问环节</li>
</ol>
<p>这家公司的HR是最有亲和力的，也是最好的，会和你综合分析手上的offer，个人发展前景等等</p>
<h1 id="金融人工智能c开发-已发offer">金融人工智能C++开发 （已发Offer）</h1>
<h3 id="初试">初试</h3>
<p>进来也是直接写笔试题</p>
<p>7道算法题，全部手写，因为赶时间（当时下午约了两场面试），只写了前5道</p>
<ol type="1">
<li>二分查找（左闭右开区间版本的实现）</li>
<li>统计子串在主串里的个数（KMP算法，这个我熟哈哈）</li>
<li>写一个排序算法（写了快速排序）</li>
<li>实现atoi函数（把int值溢出也考虑了进去，惊艳到了面试官，哈哈）</li>
<li>反转链表（写了递归的实现）</li>
</ol>
<p>问答环节：</p>
<ol type="1">
<li>快排的另一种实现方法了解吗（了解，双指针的方法）</li>
<li>反转链表的迭代实现会么（会）</li>
<li>KMP算法的原理是什么</li>
<li>sizeof的一些题目（一般这类题目都是看你了不了解 C/C++中字符数组初始化会携带结束符、数组会自动退化成指针、空类默认占1个字节等..）</li>
<li>内存对齐是什么？为什么要内存对齐？</li>
<li>关于内存的的一些基础知识（指针是值传递、堆内存和栈内存的区别等等）</li>
<li><code>std::future</code>了解吗？</li>
</ol>
<h3 id="复试">复试</h3>
<ol type="1">
<li>聊一聊你对面向对象特性，封装、继承、多态的理解</li>
<li>抽象工厂模式的具体实现？有什么好处？</li>
<li>虚函数原理（同样聊的也比较深）</li>
<li>类的成员函数怎么分辨不同对象实例（非静态成员函数调用时会隐式传递this指针，然后通过offset访问对象的成员变量。会逆向的不可能不知道这个）</li>
<li>vector和list的区别，vector是如何扩容的？扩容时会发生什么？</li>
<li>STL里的算法，容器是如何联系在一起的？（迭代器、类型萃取。还好看过STL源码解析，哈哈）</li>
<li>说一说epoll</li>
<li>你的线程池是如何实现的？</li>
<li><code>std::future</code>是干嘛的，能解决什么问题？</li>
<li>线程同步有哪些方法？实际应用时如何做抉择？</li>
<li>智能指针shared_ptr的原理？</li>
<li>weak_ptr和shared_ptr的区别？应用场景是什么？</li>
<li>make_shared的优势有哪些？（可以用auto保证语句简洁、保证了异常安全。没说出性能优势：make_shared会一次性在堆上分配足够容纳控制块和管理对象的内存。而使用构造函数会触发二次堆分配，产生额外的开销）</li>
<li>反问环节</li>
</ol>
<p>这家感觉面试难度应该是最大的了，需要写这么多算法题...</p>
<h1 id="音视频c开发-未发offer">音视频C++开发 （未发Offer）</h1>
<p>进来依旧是笔试题</p>
<ol type="1">
<li>sizeof的题目</li>
<li><code>i += (i++)</code>, <code>i += (++i)</code>，<code>(++i) += (i++)</code>, <code>(i++) += (i++)</code>的弱智题目...我告诉面试官除了最后一个会报错（i++是右值，无法+=），其他题目看不出有啥实际的考核意义，顺便表示谁要是在真正的开发中写出这种代码，我非打死他不可（当时面试官好像对我的想法不太认同）。</li>
<li>手写在一个数组里找到第二大的数（写的O(N)的实现，当时表示还有排序的方法，但时间复杂度是O(NlogN))</li>
<li>手写添加节点到链表尾部</li>
<li>手写删除链表中指定节点 （这题面试官说说有问题，我再看了一遍，确定没问题，给他讲了一遍，他发现是他错了）</li>
</ol>
<p>自此，这个面试官恼羞成怒，开始故意刁难我...</p>
<p>问答环节：</p>
<p>开始问项目 1. 我觉得你的线程池问题很大 2. 我觉得你这个小顶堆有问题 3. 我觉得你这样做，性能会很差呀</p>
<p>和他解释了半天，发现他连小顶堆都不是很清楚，就是为了故意刁难我，所以我后面直接拍桌子走人了</p>
<p>体验最差劲的一次面试，真是家垃圾公司...</p>
<h1 id="信息安全go开发-已发offer">信息安全Go开发 （已发Offer）</h1>
<p>leader直接微信联系的我，表示看过我的Github和博客，技术方面很信任，就没怎么问技术问题</p>
<ol type="1">
<li>自我介绍</li>
<li>目前手上Offer情况</li>
<li>反问环节</li>
</ol>
<p>表示对人才的渴望，并开出了很有竞争力的薪资，非常好的leader。期待以后可以有合作</p>
<h1 id="信息安全c开发已发offer">信息安全C++开发（已发Offer）</h1>
<p>没有笔试，没有算法，面试难度不大</p>
<ol type="1">
<li>自我介绍</li>
<li>Windows内核了解到什么程度？（ring3进入ring0的过程，SSDT/SSSDT，32位下SSDT Hook，进程/线程的内核结构及与Linux系统的不同）</li>
<li>你以前实习用过Vue，请你解释一下Vue数据绑定的原理（因为我女朋友是写前端的，而且正好是Vue方向的，所以这题我当然烂熟于心，哈哈）</li>
<li>看到你技术博客里有Sunday算法，请你解释一下Sunday算法</li>
<li>你的改进版Sunday算法是如何实现支持通配符的？</li>
<li>C++的一些基础题</li>
<li>你觉得你自己最大的优点是什么？</li>
<li>你觉得你自己最大的缺点是什么？</li>
<li>你在以前的项目开发中，遇到最大的难题是什么？</li>
<li>你对信息安全的理解？</li>
<li>你知道哪些的攻击方式，你有过实战吗？（XSS攻击还真有实战经验）</li>
<li>反问环节</li>
</ol>
<h1 id="总结">总结</h1>
<p>共面试了9家，7家拿到了Offer</p>
<p>目前已签最后一家信息安全公司</p>
]]></content>
      <categories>
        <category>面试经验</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>计算机网络</tag>
        <tag>操作系统</tag>
        <tag>数据结构</tag>
        <tag>面试经验</tag>
      </tags>
  </entry>
  <entry>
    <title>libmemif源码分析</title>
    <url>/2021/09/26/libmemif-source-code-analysis/</url>
    <content><![CDATA[<h1 id="libmemif">libmemif</h1>
<p>memif是Mmeory Interface的缩写，memif库实现了进程间<strong>高性能</strong>数据包传输</p>
<h1 id="为什么高性能">为什么高性能？</h1>
<ul>
<li>共享内存实现进程间通信</li>
<li>无锁环形缓冲区 + 批量收发 + 双缓冲实现数据包传输</li>
<li>epoll实现事件模式</li>
</ul>
<blockquote>
<p>环形缓冲区也称为循环队列</p>
</blockquote>
<h1 id="特点">特点</h1>
<ul>
<li>支持多线程</li>
<li>支持0拷贝</li>
<li>支持epoll外部处理</li>
<li>支持中断(事件)模式或轮询模式</li>
</ul>
<a id="more"></a>
<h1 id="常用结构体">常用结构体</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** \brief Memif连接参数</span></span><br><span class="line"><span class="comment">    @param socket - Memif socket 句柄, 为 NULL 时使用默认 socket.</span></span><br><span class="line"><span class="comment">		    默认套接字仅在全局数据库中受支持（参见memif_init）。</span></span><br><span class="line"><span class="comment">            自定义数据库不创建默认套接字（参见memif_per_thread_init）。</span></span><br><span class="line"><span class="comment">            Memif连接与套接字存储在同一数据库中.</span></span><br><span class="line"><span class="comment">    @param secret - 用作身份验证的可选参数</span></span><br><span class="line"><span class="comment">    @param num_s2m_rings - 主机到从机的环形缓冲区数量</span></span><br><span class="line"><span class="comment">    @param num_m2s_rings -  从机到主机的环形缓冲区数量</span></span><br><span class="line"><span class="comment">    @param buffer_size - 共享内存中缓冲区的大小</span></span><br><span class="line"><span class="comment">    @param log2_ring_size - 环形缓冲区的大小（以2为底的对数）</span></span><br><span class="line"><span class="comment">    @param is_master - 0 == 主机, 1 == 从机</span></span><br><span class="line"><span class="comment">    @param interface_id - 用于标识对等连接的id</span></span><br><span class="line"><span class="comment">    @param interface_name - 接口名</span></span><br><span class="line"><span class="comment">    @param mode - 0 == 以太网（运行在2层）, 1 == ip（运行在3层） , 2 == punt/inject</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">memif_socket_handle_t</span> socket;	<span class="comment">/*!&lt; 默认 = /run/vpp/memif.sock */</span></span><br><span class="line">  <span class="type">uint8_t</span> secret[<span class="number">24</span>];		<span class="comment">/*!&lt; 可选 (身份验证) */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> num_s2m_rings;	<span class="comment">/*!&lt; 默认 = 1 */</span></span><br><span class="line">  <span class="type">uint8_t</span> num_m2s_rings;	<span class="comment">/*!&lt; 默认 = 1 */</span></span><br><span class="line">  <span class="type">uint16_t</span> buffer_size;		<span class="comment">/*!&lt; 默认 = 2048 */</span></span><br><span class="line">  <span class="type">uint8_t</span> log2_ring_size;	<span class="comment">/*!&lt; 默认 = 10 (1 &lt;&lt; 10 = 1024) */</span></span><br><span class="line">  <span class="type">uint8_t</span> is_master;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> interface_id;</span><br><span class="line">  <span class="type">uint8_t</span> interface_name[<span class="number">32</span>];</span><br><span class="line">  <span class="type">memif_interface_mode_t</span> mode:<span class="number">8</span>;</span><br><span class="line">&#125; <span class="type">memif_conn_args_t</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** \brief Memif 数据包缓冲区</span></span><br><span class="line"><span class="comment">    @param desc_index - 环形缓冲区描述符索引</span></span><br><span class="line"><span class="comment">    @param ring - 指向包含此缓冲区描述符的环形缓冲区的指针</span></span><br><span class="line"><span class="comment">    @param len - 数据有效长度</span></span><br><span class="line"><span class="comment">    @param flags - 标志位</span></span><br><span class="line"><span class="comment">    @param data - 指向共享内存数据的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> desc_index;</span><br><span class="line">  <span class="type">void</span> *ring;</span><br><span class="line">  <span class="type">uint32_t</span> len;</span><br><span class="line"><span class="comment">/** 表示buffer不够大，无法包含整个数据包，因此下一个缓冲器包含包的其余部分（链式缓冲区） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMIF_BUFFER_FLAG_NEXT (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="comment">/** 表示buffer来自Rx环形缓冲区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMIF_BUFFER_FLAG_RX (1 &lt;&lt; 1)</span></span><br><span class="line">  <span class="type">uint8_t</span> flags;</span><br><span class="line">  <span class="type">void</span> *data;</span><br><span class="line">&#125; <span class="type">memif_buffer_t</span>;</span><br></pre></td></tr></table></figure>
<h1 id="常用api">常用API</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** \brief Memif 初始化</span></span><br><span class="line"><span class="comment">    @param on_control_fd_update - 文件描述符事件轮询回调函数（用于自定义epoll）</span></span><br><span class="line"><span class="comment">    @param app_name - 应用程序名称（被截断为32个字符）</span></span><br><span class="line"><span class="comment">    @param memif_alloc - 自定义内存分配器, NULL = 默认（malloc）</span></span><br><span class="line"><span class="comment">    @param memif_realloc - 自定义内存重分配器, NULL = 默认（realloc）</span></span><br><span class="line"><span class="comment">    @param memif_free - 自定义内存释放器, NULL = 默认（free）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果参数on_control_fd_update设置为NULL，libmemif将在内部处理文件描述符事件轮询如果设置了有效的回调，则需要通过用户应用程序，所有文件描述符和事件类型都将传入此回调将返回到用户应用程序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    初始化内部libmemif结构。创建timerfd（用于在从属模式下通过断开连接的memifs定期请求连接，无需额外的API调用）。此fd通过memif_control_fd_update_t传递给用户</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    计时器在此状态下处于非活动状态。如果在从属模式下至少有一个memif，则会激活。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    \return memif_err_t</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memif_init</span> <span class="params">(<span class="type">memif_control_fd_update_t</span> * on_control_fd_update,</span></span><br><span class="line"><span class="params">		<span class="type">char</span> *app_name, <span class="type">memif_alloc_t</span> * memif_alloc,</span></span><br><span class="line"><span class="params">		<span class="type">memif_realloc_t</span> * memif_realloc, <span class="type">memif_free_t</span> * memif_free)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** \brief 创建内存接口并连接</span></span><br><span class="line"><span class="comment">    @param conn - 返回连接句柄 [out]</span></span><br><span class="line"><span class="comment">    @param args - 连接参数</span></span><br><span class="line"><span class="comment">    @param on_connect - 连接上触发的回调函数</span></span><br><span class="line"><span class="comment">    @param on_disconnect - 断开连接触发的回调函数</span></span><br><span class="line"><span class="comment">    @param on_interrupt - 通知用户中断，如果设置为null，则不会通知用户中断，用户可以使用memif_get_queue_efd调用获取中断fd以轮询事件</span></span><br><span class="line"><span class="comment">    @param private_ctx - 通过回调传递回用户的上下文指针</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    主机模式 -</span></span><br><span class="line"><span class="comment">        Start timer that will send events to timerfd. If this fd is passed to memif_control_fd_handler</span></span><br><span class="line"><span class="comment">        every disconnected memif in slave mode will send connection request.</span></span><br><span class="line"><span class="comment">        On success new fd is passed to user with memif_control_fd_update_t.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    从机模式 -</span></span><br><span class="line"><span class="comment">        Create listener socket and pass fd to user with memif_control_fd_update_t.</span></span><br><span class="line"><span class="comment">        If this fd is passed to memif_control_fd_handler accept will be called and</span></span><br><span class="line"><span class="comment">        new fd will be passed to user with memif_control_fd_update_t.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    \return memif_err_t</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memif_create</span> <span class="params">(<span class="type">memif_conn_handle_t</span> * conn, <span class="type">memif_conn_args_t</span> * args,</span></span><br><span class="line"><span class="params">		  <span class="type">memif_connection_update_t</span> * on_connect,</span></span><br><span class="line"><span class="params">		  <span class="type">memif_connection_update_t</span> * on_disconnect,</span></span><br><span class="line"><span class="params">		  <span class="type">memif_interrupt_t</span> * on_interrupt, <span class="type">void</span> *private_ctx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** \brief 发送缓冲区脉冲</span></span><br><span class="line"><span class="comment">    @param conn - 连接句柄</span></span><br><span class="line"><span class="comment">    @param qid - 队列ID</span></span><br><span class="line"><span class="comment">    @param bufs - 数据包缓冲区(数组)</span></span><br><span class="line"><span class="comment">    @param count - 要传输的数据包缓冲区数量</span></span><br><span class="line"><span class="comment">    @param tx - 返回已传输的数据包缓冲区数量 [out]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    \return memif_err_t</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memif_tx_burst</span> <span class="params">(<span class="type">memif_conn_handle_t</span> conn, <span class="type">uint16_t</span> qid,</span></span><br><span class="line"><span class="params">		    <span class="type">memif_buffer_t</span> * bufs, <span class="type">uint16_t</span> count, <span class="type">uint16_t</span> * tx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** \brief 接受缓冲区脉冲</span></span><br><span class="line"><span class="comment">    @param conn - 连接句柄</span></span><br><span class="line"><span class="comment">    @param qid - 队列ID</span></span><br><span class="line"><span class="comment">    @param bufs - 数据包缓冲区(数组)</span></span><br><span class="line"><span class="comment">    @param count - 要接收的数据包缓冲区数量</span></span><br><span class="line"><span class="comment">    @param rx - 返回已接收的数据包缓冲区数量 [out]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    为接收队列消耗中断事件.</span></span><br><span class="line"><span class="comment">    如果memif_rx_burst失败，则事件不会被消费.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    \return memif_err_t</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">memif_rx_burst</span> <span class="params">(<span class="type">memif_conn_handle_t</span> conn, <span class="type">uint16_t</span> qid,</span></span><br><span class="line"><span class="params">		    <span class="type">memif_buffer_t</span> * bufs, <span class="type">uint16_t</span> count, <span class="type">uint16_t</span> * rx)</span>;</span><br></pre></td></tr></table></figure>
<h1 id="源码分析">源码分析</h1>
<blockquote>
<p>下文中的<strong>消息队列</strong>指的是建立socket连接后，libmemif使用单链表实现的简单队列，用于进行建立连接类的消息通讯</p>
</blockquote>
<blockquote>
<p>下文中的<strong>数据传输队列</strong>指的是建立memif连接后，libmemif使用共享内存实现的环形缓冲区，用于进行数据包的传输</p>
</blockquote>
<img data-src="/2021/09/26/libmemif-source-code-analysis/control.drawio.png" class="">
<h2 id="初始化memif_init流程">初始化<code>memif_init</code>流程</h2>
<ol type="1">
<li>注册自定义内存管理函数</li>
<li>注册自定义epoll轮询回调函数</li>
<li>初始化连接列表、中断列表、socket列表等</li>
<li>创建定时器，并初始化为2秒(用于重连)</li>
<li>创建默认memif_socket_t结构体（注意！不是socket）</li>
</ol>
<h2 id="创建memif_create流程">创建<code>memif_create</code>流程</h2>
<ol type="1">
<li>将连接参数、回调函数等添加到memif_socke的interface_list里</li>
<li>如果是主机，就开始监听连接（监听到的从机socket连接添加socket_list里，并挂到epoll上）</li>
<li>如果是从机，就将连接参数添加到control_list里（由于还没连上主机，所以此时contort_list里的fd是-1），并尝试连接到主机（如果连接失败就启动定时器一直尝试重连）</li>
</ol>
<h2 id="请求连接memif_request_connection流程">请求连接<code>memif_request_connection</code>流程</h2>
<ol type="1">
<li>创建<code>AF_UNIX</code>域socket，尝试连接到主机</li>
<li>注册socket的读、写回调（关键！读回调用于与主机进行简单的通信。协商创建共享内存域、环形缓冲区等等，写回调用于发送消息队列中的消息给对端）</li>
<li>修改control_list里的fd为socket的fd，并将fd挂到epoll上（用于通知读、写回调）</li>
<li>（如果连接失败就启动定时器一直尝试重连）</li>
</ol>
<h2 id="主机accept后流程">主机accept后流程</h2>
<ol type="1">
<li>直接发送HELLO消息（不使用消息队列）</li>
</ol>
<h2 id="hello消息处理流程">HELLO消息处理流程</h2>
<ol type="1">
<li>协商队列数量、单个数据包大小。获取对端接口名等</li>
<li>初始化共享内存域和循坏队列(数据传输队列、消息传输队列)</li>
<li>接口密码（可选）消息入队</li>
<li>共享内存域、环形缓冲区的信息入队</li>
</ol>
<h2 id="init消息处理流程">INIT消息处理流程</h2>
<ol type="1">
<li>处理接口密码（可选）入队</li>
<li>ACK入队</li>
</ol>
<h2 id="创建数据传输队列流程">创建数据传输队列流程</h2>
<ol type="1">
<li>根据连接参数，先创建合适大小的共享内存</li>
<li>将共享内存分为2个区域，区域0存储环形缓冲区的信息；区域1存储具体的数据包内容</li>
<li>创建数据传输队列，每个数据传输队列有2个环形缓冲区：Rx和Tx</li>
<li>为每个环形缓冲区都创建一个eventfd</li>
</ol>
<blockquote>
<p>eventfd用于写入数据后，触发对端的中断on_interrupt回调</p>
</blockquote>
<h2 id="传送数据包memif_tx_burst过程">传送数据包<code>memif_tx_burst</code>过程</h2>
<ol type="1">
<li>根据队列ID拿到对应的Tx环形缓冲区(下文称为ring)</li>
<li>计算掩码（用于确定数据包缓冲区在ring中的位置）</li>
<li>循环要传输的数据包</li>
<li>使用内存屏障保证所有数据包已经正确写入长度</li>
<li>触发对端的中断on_interrupt回调</li>
</ol>
<h2 id="接收数据包memif_rx_burst过程">接收数据包<code>memif_rx_burst</code>过程</h2>
<ol type="1">
<li>根据队列ID拿到对应的Rx环形缓冲区(下文称为ring)</li>
<li>计算掩码（用于确定数据包缓冲区在ring中的位置）</li>
<li>循环取出数据包</li>
<li>如果是从机，在取完数据后需要重置数据包缓冲区大小</li>
<li>记录下这次已经处理完ring的索引（用于下次确定从ring的哪里开始读取数据包）</li>
</ol>
<h1 id="扩展知识">扩展知识</h1>
<h2 id="为啥环形缓冲区高性能">为啥环形缓冲区高性能？</h2>
<p>当一个数据元素被用掉后，其余数据元素不需要移动其存储位置，从而减少拷贝提高效率</p>
<h2 id="为啥循环缓冲区的大小只能是以2为底的对数">为啥循环缓冲区的大小只能是以2为底的对数？</h2>
<p>实现环形缓冲区需要使用<strong>取模运算</strong>（用于确定头、尾指针在环中的位置）</p>
<p>而众所周知位运算是最快的一组运算，当然也比取模运算快</p>
<p>而所有以2为第的对数，都可以将取模运算转换成位运算</p>
<p>即：若 $ M = 2^x $且 <span class="math inline">\(x\)</span> 为自然数，则以下公式成立 <span class="math display">\[ M \bmod N =  M\ \\\&amp;\ (\ N\ -\ 1\ ) \]</span></p>
<p>所以<code>8 % 7</code>就可以写成 <code>8 &amp; (7 - 1)</code>，提高了运算性能</p>
<details>
<p><summary>等式证明</summary></p>
<p>假设$ M = 8 = 2^3 <span class="math inline">\(，那么\)</span> M - 1 = 7 $，二进制为<code>0000 0111b</code></p>
<ol type="1">
<li><p>若 $ M &lt; 8 $， $ M = M $ , $ M  = M $，等式成立</p></li>
<li><p>若 $ M &gt; 8 <span class="math inline">\(，\)</span> M = 2<sup>a+2</sup>b+2^c+... $ 比如，$ 51 = 1+2+16+32 = 2<sup>0+2</sup>1+2<sup>4+2</sup>5 $ ，求 $ 51  $时，由于7的二进制是<code>0000 0111b</code>，所以2的幂只要大于等于<span class="math inline">\(2^3\)</span>的数，与上7结果都是0，所以$ 2^4  = 0 , 2^5 \&amp; 7 = 0, (2<sup>0+2</sup>1+2<sup>4+2</sup>5) \&amp; (7) = 2<sup>0+2</sup>1=3 <span class="math inline">\(。而根据结论1，\)</span>(2<sup>0+2</sup>1) \&amp; 7 = (2<sup>0+2</sup>1)  <span class="math inline">\(，所以\)</span> 51 \&amp; 7=51  $</p></li>
</ol>
<p>综上得证。</p>
</details>
<h2 id="为啥可以实现无锁并发">为啥可以实现无锁并发？</h2>
<ol type="1">
<li><p><code>volatile</code>关键字</p></li>
<li><p>内存屏障</p></li>
<li><p><code>volatile</code>关键字阻止了编译器为了提高速度将变量缓存起来，而修改后不写回</p></li>
<li><p>内存屏障阻止了现代CPU的乱序执行，保证在屏障之前的指令不会在屏障之后执行</p></li>
</ol>
<p>这样就保证了传输数据时，每个数据包的长度都被正确写入后，再通知对端</p>
<p>如果不加内存屏障，可能数据、数据长度还没写完，由于CPU的乱序执行优化，就通知对端，这样读到的缓冲区内的数据就不完整</p>
<blockquote>
<p>只能在单生产/单消费模式时不需要加锁同步</p>
</blockquote>
<h2 id="为啥源码中关于socket消息的结构体都有__attribute__packed">为啥源码中关于socket消息的结构体都有<code>__attribute__((packed))</code>？</h2>
<h3 id="这个编译指令是什么">这个编译指令是什么？</h3>
<p>告诉编译器按照实际占用字节数进行<strong>内存对齐</strong></p>
<h3 id="存在的意义">存在的意义？</h3>
<p>其实这里的做法和Linux内核中关于网络协议的实现一致</p>
<p>因为不同平台（指操作系统、编译器等）的内存对齐方式不同，如果使用结构体进行平台间的通信，就可能会有问题</p>
<p>举例： 假设没有使用 <code>__attribute__((packed))</code></p>
<p>发送消息的程序是GCC编译的，<code>xxx_msg_t</code>结构体默认的内存对齐策略为24字节，而接受消息的程序是另一个编译器，而另一个编译器下<code>xxx_msg_t</code>结构体默认的内存对齐策略为32字节（只是随便举个例子），那么每个变量对应的值就不对了。</p>
<h2 id="memif_ring_t里的cacheline是个什么玩意"><code>memif_ring_t</code>里的cacheline是个什么玩意？</h2>
<h3 id="cache-line是什么">Cache Line是什么？</h3>
<p>由于CPU高速缓存的存在，CPU不再是按字节访问内存，而是以64字节为单位的块(Chunk)拿取，称为一个缓存行(Cache Line)</p>
<p>而当你读一个特定的内存地址，整个缓存行将从主存/低速缓存换入高速缓存，以提供高速访问</p>
<blockquote>
<p>这时候有大聪明要问了，为啥CPU不能直接读主存呢，多省事啊？因为CPU运行速度极快，而主存完全跟不上CPU的速度，直接读主存会拖累CPU的运行速度（CPU长时间处于等待IO状态中）</p>
</blockquote>
<h3 id="cache-line对齐是什么">Cache Line对齐是什么？</h3>
<p>默认情况下，结构体内存会按照数据大小对齐, 而Cache Line对齐就是将结构体的内存对齐到与Cache Line的大小一致</p>
<h3 id="存在的意义-1">存在的意义？</h3>
<p>Cache Line对齐是对CPU缓存优化的一种方式</p>
<p>一般来说</p>
<p>如果按数据大小对齐，结构体里的数据可能会跨Cache行存放，CPU读取时就需要访问多次缓存行，影响性能</p>
<p>而我们可以将结构体按照一个缓存行的大小（64字节）进行内存对齐</p>
<p>这样就可以一次将整个结构体读入Cache中，减少CPU高级缓存与低级缓存、内存的数据交换次数</p>
<p>但在<code>memif_ring_t</code>中，其实另有其他更重要的作用</p>
<h3 id="在memif_ring_t里使用cache-line对齐意义">在<code>memif_ring_t</code>里使用Cache Line对齐意义？</h3>
<ul>
<li>cacheline0的作用</li>
</ul>
<p>这行的意义不明，在GCC下有没有这行都一样。个人猜测应该是为了GDB调试时方便查看结构体的内存布局</p>
<ul>
<li>cacheline1和cacheline2的作用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">....</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint16_t</span> head;</span><br><span class="line">    MEMIF_CACHELINE_ALIGN_MARK (cacheline1); </span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint16_t</span> tail;</span><br><span class="line">    MEMIF_CACHELINE_ALIGN_MARK (cacheline2);</span><br><span class="line">....</span><br><span class="line">&#125; <span class="type">memif_ring_t</span>;</span><br></pre></td></tr></table></figure>
<p>强制head与tail不在同的Cache Line中</p>
<h4 id="为什么需要将两个volatile变量存在不同的cache-line中">为什么需要将两个<code>volatile</code>变量存在不同的Cache Line中？</h4>
<p>为了解决<strong>伪共享</strong>的问题</p>
<img data-src="/2021/09/26/libmemif-source-code-analysis/volatile.png" class="">
<p>在多CPU环境下，首先明确<code>volatile</code>变量在某个CPU修改后，在写回时，会通知其他CPU重新读取缓存，以确保一致性</p>
<img data-src="/2021/09/26/libmemif-source-code-analysis/false-sharing.png" class="">
<p>如果<strong>两个</strong><code>volatile</code>变量<code>X</code>和<code>Y</code>在<strong>同一个</strong>Cache Line，而这两个变量某一个被修改时，由于<code>volatile</code>的特性，另一个CPU就会被通知重读缓存。这种无谓的通知就浪费了性能。这种现象就叫<strong>伪共享</strong></p>
<img data-src="/2021/09/26/libmemif-source-code-analysis/cache-line-align.png" class="">
<p>而将两个<code>volatile</code>的变量放到不同的Cache Line中，就不需要一直通知另一个CPU更新数据了，因为另一个CPU根本没有也不需要这个数据</p>
<img data-src="/2021/09/26/libmemif-source-code-analysis/GDB.png" class="">
<blockquote>
<p>Linux下查看Cache Linux大小<code>$ cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size</code></p>
</blockquote>
<h2 id="如何进一步提高性能">如何进一步提高性能？</h2>
<ol start="0" type="1">
<li>memif的最关键的性能瓶颈在于数据包的拷贝，所以可以尝试使用SIMD（AVX2、AVX512）指令集提高拷贝性能</li>
<li>在流量密集情况下使用轮询模式，而非中断模式，减少中断开销（实现NAPI）</li>
<li>使用自定义的内存管理模块（比如内存池）。以提高缓存命中、减低内存碎片化</li>
<li>如果你的程序中有其他模块需要使用到epoll，请使用自定义的epoll，以减少多余的内存消耗、以及多个线程epoll_wait的开销</li>
<li>实现0拷贝（直接修改接收到的数据包，再直接重新入队）</li>
<li>使用线程池实现多线程（不要开太多工作线程，一般与CPU核心数一致即可，减少CPU在线程上下文的切换成本）</li>
</ol>
<blockquote>
<p>epoll使用红黑树实现，提供O(logN)的查询时间复杂度，即使大量挂载也比多开几个epoll的成本（额外的CPU线程上下文切换成本、内存成本）小</p>
</blockquote>
<h1 id="常见qa">常见Q&amp;A</h1>
<blockquote>
<p>Q: 连接不上，抛出<code>Connection refused</code>异常，或刚连就直接触发<code>Disconnect</code>事件</p>
<p>A: 检查两个进程之间连接参数是否一致！比如<code>Socket</code>的位置、<code>Rx / Tx</code>队列数是否一致等等</p>
</blockquote>
<blockquote>
<p>Q: 无法向共享内存缓冲区<code>memif_buffer_t</code>中拷贝数据，抛出<code>segmentation fault</code>异常</p>
<p>A: 检查是否手动为共享内存缓冲区<code>memif_buffer_t</code>分配内存。注意：这里的手动分配内存不是指调用<code>memif_buffer_alloc</code></p>
</blockquote>
<blockquote>
<p>Q: 连接正常，但发出去的数据对面收不到，也都不抛出异常</p>
<p>A: 检查对方是否正确的实现了<code>on_interrupt</code>或轮询</p>
</blockquote>
<blockquote>
<p>Q: 我想用我自己的epoll（自己处理epoll事件）怎么办?</p>
<p>A: <code>memif_init</code>时传入epoll事件的回调，可以参考<code>/examples/icmp_responder-epoll</code>中的实现</p>
</blockquote>
<blockquote>
<p>Q: <code>memif_init</code>报错怎么办?</p>
<p>A: 确保你的<code>memif_init</code>整个进程运行时只被调用过一次</p>
</blockquote>
]]></content>
      <categories>
        <category>memif</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>缓存</tag>
        <tag>高性能</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>一题引出C++内存管理和设计原则</title>
    <url>/2021/01/15/mem-managerment-and-design-principles/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>最近在刷LeetCode，昨天做到了这一题 <a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a>，题目很简单，官方题解中，给出的Java代码如下 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作者：LeetCode</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/shan-chu-lian-biao-zhong-de-jie-dian-by-leetcode/</span></span><br><span class="line"><span class="comment">// 来源：力扣（LeetCode）</span></span><br></pre></td></tr></table></figure> 可以看出，官方题解的思路是直接将自身<strong>替换</strong>成了下一个节点</p>
<p>我平时使用C++来做题，但如果简单的将上述代码修改成C++就可能会导致严重的<strong>内存泄漏</strong>事故</p>
<a id="more"></a>
<h1 id="c内存释放">C++内存释放</h1>
<p>大家都知道Java是有垃圾回收也就是GC的，所以上述代码在Java中是完全没有问题的，因为被替换掉的节点会由GC来释放</p>
<p>而在C++中，每一个被<code>new</code>出来的<em>原生指针</em>(<em>Raw Pinter</em>)都必须使用<code>delete</code>释放，不释放会内存泄漏</p>
<p>那我们直接写成下面这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        ListNode* del = node-&gt;next;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> del;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可能到这里，大部分人就觉得OK了，万无一失了。</p>
<p>但C++中的对象是分为<em>静态分配</em>和<em>动态分配</em>的</p>
<p>确实在大部分情况下是没有问题了，但，<code>delete</code>只能用于释放堆指针，也就是<code>new</code>出来的指针，而不能用于栈指针。</p>
<p>所以以下代码在VC++ Debug下会抛出<code>_CrtIsValidHeapPointer(block)</code>或<code>is_block_type_valid(header-&gt;block_use)</code>异常，因为C运行时检测到了你要<code>delete</code>的指针不是一个堆指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ListNode <span class="title">a</span><span class="params">(<span class="number">4</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">5</span>)</span>, <span class="title">c</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">d</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    a.next = &amp;b;</span><br><span class="line">    b.next = &amp;c;</span><br><span class="line">    c.next = &amp;d;</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.<span class="built_in">deleteNode</span>(&amp;b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然有人要说了，这是个链表节点啊，谁会静态分配啊，静态分配不就没意义了嘛！</p>
<p>但为了以防万一，还是需要使用设计来限制<code>NodeList</code>只能动态分配</p>
<h1 id="只能动态分配">只能动态分配</h1>
<p>简单来说，只需要将构造、析构函数设为<code>protected</code>属性，再将将动态分配的职责给到静态函数即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="function"><span class="type">static</span> ListNode* <span class="title">create</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ListNode</span>(x); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ListNode a(4);  错误： 构造函数不可访问</span></span><br><span class="line">    ListNode* a = ListNode::<span class="built_in">create</span>(<span class="number">4</span>);</span><br><span class="line">    ListNode* b = ListNode::<span class="built_in">create</span>(<span class="number">5</span>);</span><br><span class="line">    ListNode* c = ListNode::<span class="built_in">create</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* d = ListNode::<span class="built_in">create</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    a-&gt;next = b;</span><br><span class="line">    b-&gt;next = c;</span><br><span class="line">    c-&gt;next = d;</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    solution.<span class="built_in">deleteNode</span>(b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以保证<code>deleteNode</code>函数不会<code>delete</code>到栈指针了</p>
<h1 id="设计原则">设计原则</h1>
<h2 id="存在的错误">存在的错误</h2>
<p>经过上面的改造，大部分人可能就觉得没有啥问题了。但官方给出的“<strong>删除</strong>”真的是删除吗？</p>
<p>很显然这不是真正的删除了该删除的节点，而是将原节点修改了值。</p>
<img data-src="/2021/01/15/mem-managerment-and-design-principles/debug.png" class="">
<p>在Dbueg下看到，<code>deleteNode</code>函数从语义上看是删除了<code>b</code>节点，但实际上，<code>b</code>节点还存在，而<code>c</code>节点却被<code>delete</code>了。</p>
<p>这就要引出另一个问题了，如果在<code>deleteNode</code>前在使用<code>c</code>节点本身，那就可能引发不确定行为。</p>
<h2 id="对题目的反思">对题目的反思</h2>
<p>由于<code>ListNode</code>是个单链表节点，而单链表节点本质上是无法做到在链表里删除自身的，所以这题只能通过这种替换的方式来伪造删除了节点。</p>
<p>这题会误导很多开发者，这题的设计模式更是不可取！</p>
<p>个人认为这题应该删除</p>
<p>而<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a>这题才是真正的移除链表元素！</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数表（VMT）Hook</title>
    <url>/2020/12/07/vmt-hook/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p><strong>虚函数表（VMT）Hook</strong>，又叫指针重定向，是一种常见的Hook技术，在游戏外挂程序中最常见。且多用于在Direct3D / OpenGL引擎游戏里实现内置叠加层。</p>
<h1 id="虚函数表vmt">虚函数表（VMT）</h1>
<blockquote>
<p>本文中VMT就代指虚函数表。</p>
</blockquote>
<p>虚函数表是C++实现多态的一种方式。</p>
<p>每一个有虚函数的类（或有虚函数类的派生类）都有一个VMT，VMT本质上就是一个函数指针数组，通常位于对象内存布局的开头或结尾。每当C++类声明虚(<code>virtual</code>)函数时，编译器都会增加一个条目到VMT中。</p>
<a id="more"></a>
<p>例如，在x86系统上使用VS2019编译以下代码： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;-  Base::Base\n&quot;</span>; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;-  Base::~Base\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;-  Base::A\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;-  Base::B\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">C</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;-  Base::C\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">final</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;-  Derived::Derived\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;-  Derived::~Derived\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;-  Derived::B\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">C</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;-  Derived::C\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <code>Base</code>类有三个虚函数：<code>~Base</code>、<code>B</code>和<code>C</code>. <code>Derived</code>类派生自<code>Base</code>，并重写了两个虚函数<code>B</code>h和<code>C</code>.</p>
<p>这里我们创建三个实例 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base base;</span><br><span class="line">Derived derived;</span><br><span class="line">Base* pBase = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br></pre></td></tr></table></figure> 我们把代码跑起来，用调试器观察，发现<code>Base</code>实例的VMT包含了<code>~Base</code>、<code>B</code>和<code>C</code></p>
<img data-src="/2020/12/07/vmt-hook/base.png" class="">
<p>而两个<code>Derived</code>实例的VMT包含了<code>~Derived</code>、<code>B</code>和<code>C</code>。但VMT里的函数地址与<code>Base</code>实例中的不一样（见下图）</p>
<img data-src="/2020/12/07/vmt-hook/derived.png" class="">
<img data-src="/2020/12/07/vmt-hook/pBase.png" class="">
<p>那么应该如何使用这些函数呢？</p>
<p>以一个函数为例，该函数获取一个指向<code>Base</code>的指针并调用函数<code>A</code>，<code>B</code>和<code>C</code>： <figure class="highlight cpp"><figcaption><span>Invoke</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Invoke</span><span class="params">(Base* <span class="type">const</span> pBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pBase-&gt;<span class="built_in">A</span>();</span><br><span class="line">    pBase-&gt;<span class="built_in">B</span>();</span><br><span class="line">    pBase-&gt;<span class="built_in">C</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 以以下方式调用： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Invoke</span>(&amp;base);</span><br><span class="line"><span class="built_in">Invoke</span>(&amp;derived);</span><br><span class="line"><span class="built_in">Invoke</span>(pBase);</span><br></pre></td></tr></table></figure></p>
<p>将<code>Invoke</code>函数反汇编，看看在汇编层面，VMT内的函数是如何被调用的： &gt; 可以将RTC关闭（项目属性-&gt;C/C++-&gt;代码生成-&gt;基本运行时检查-&gt;默认值），省去__RTC_CheckEsp等检查，让反汇编代码更简洁 &gt; <img data-src="/2020/12/07/vmt-hook/invoke-asm.png" class=""></p>
<p>对于<code>B</code>的调用，编译器将<code>pBase</code>也就是对象的地址移入<code>EAX</code>寄存器，然后间接获取VTM的基地址，并将其存储在<code>EDX</code>寄存器中。通过<code>EDX</code>作为索引+4将函数地址存储在<code>EAX</code>寄存器中，然后调用<code>EAX</code></p>
<p>对<code>C</code>的调用如出一辙，只是VMT中函数地址的偏移量为8。</p>
<p>由此可见，VMT的底层实现就是一个<strong>函数指针数组</strong>。</p>
<p>明白了VMT调用的原理，我们就可以很轻松的写一个函数来打印VMT: <figure class="highlight cpp"><figcaption><span>PrintVTable</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVTable</span><span class="params">(Base* <span class="type">const</span> pBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pVTableBase = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>***&gt;(pBase);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First: %p\n&quot;</span></span><br><span class="line">        <span class="string">&quot;Second: %p\n&quot;</span></span><br><span class="line">        <span class="string">&quot;Third: %p\n&quot;</span>,</span><br><span class="line">        pVTableBase[<span class="number">0</span>] , pVTableBase[<span class="number">1</span>], pVTableBase[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # VMT Hook的实现 明白了VMT调用的原理，当然也就可以轻松的实现Hook了。</p>
<p>我们只要覆盖掉需要Hook的函数在VMT中的地址即可，这也解释了为什么VMT Hook也叫指针重定向。 <figure class="highlight cpp"><figcaption><span>HookVMT</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HookVMT</span><span class="params">(Base* <span class="type">const</span> pBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pVTableBase = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>***&gt;(pBase);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulOldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(&amp;pVTableBase[<span class="number">1</span>], <span class="built_in">sizeof</span>(<span class="type">void</span>*), PAGE_EXECUTE_READWRITE, &amp;ulOldProtect);</span><br><span class="line">    pVTableBase[<span class="number">1</span>] = VMTHookFnc;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(&amp;pVTableBase[<span class="number">1</span>], <span class="built_in">sizeof</span>(<span class="type">void</span>*), ulOldProtect, &amp;ulOldProtect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><figcaption><span>VMTHookFnc</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">VMTHookFnc</span><span class="params">(<span class="type">void</span>* pEcx, <span class="type">void</span>* pEdx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* pThisPtr = (Base*)pEcx;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In VMTHookFnc\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里利用<code>__fastcall</code>调用约定用来获取<code>this</code>指针</p>
</blockquote>
<p>成功Hook住虚函数<code>B</code>!</p>
<img data-src="/2020/12/07/vmt-hook/output.png" class="">
<p>利用调试器，进入Hook函数中，可以看到<code>this</code>指针VMT里的<code>B</code>已经被替换成了<code>VMTHookFuc</code></p>
<img data-src="/2020/12/07/vmt-hook/hooked-ptr.png" class="">
<h1 id="封装">封装</h1>
<p>剩下的就是封装了</p>
<p>这里的命名规则遵循STL标准库的小写规则</p>
<p>这里的实现是整个VMT替换，这样也可以方便的实现获取原函数。 <figure class="highlight cpp"><figcaption><span>vmt_hook.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vmt_hook</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vmt_hook</span>(<span class="type">void</span>* obj, <span class="type">size_t</span> num_funcs);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">hook</span><span class="params">(<span class="type">size_t</span> index, <span class="type">void</span>* func)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">unhook</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function">T <span class="title">get_original</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">enable</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">disable</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">void</span>*** m_object;</span><br><span class="line">	<span class="type">size_t</span> m_num_funcs;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>** m_original_table;</span><br><span class="line">	std::unique_ptr&lt;<span class="type">void</span>*[]&gt; m_new_table;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">vmt_hook::get_original</span><span class="params">(<span class="type">size_t</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&gt;(m_original_table[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><figcaption><span>vmt_hook.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmt_hook.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">vmt_hook::<span class="built_in">vmt_hook</span>(<span class="type">void</span>* obj, <span class="type">size_t</span> num_funcs) :</span><br><span class="line">	<span class="built_in">m_object</span>(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>***&gt;(obj)),</span><br><span class="line">	<span class="built_in">m_num_funcs</span>(num_funcs + <span class="number">1</span>),</span><br><span class="line">	<span class="built_in">m_original_table</span>(*m_object),</span><br><span class="line">	<span class="built_in">m_new_table</span>(std::<span class="built_in">make_unique</span>&lt;<span class="type">void</span>*[]&gt;(m_num_funcs))</span><br><span class="line">&#123;</span><br><span class="line">	std::<span class="built_in">copy_n</span>(m_original_table - <span class="number">1</span>, m_num_funcs, m_new_table.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vmt_hook::hook</span><span class="params">(<span class="type">size_t</span> index, <span class="type">void</span>* func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_new_table[index + <span class="number">1</span>] = func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vmt_hook::unhook</span><span class="params">(<span class="type">size_t</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_new_table[index + <span class="number">1</span>] = m_original_table[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vmt_hook::enable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*m_object = m_new_table.<span class="built_in">get</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vmt_hook::disable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*m_object = m_original_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<ul>
<li><strong>执行速度:10</strong></li>
<li><strong>编写难度:3-5</strong></li>
<li><strong>检测率:3</strong></li>
</ul>
<p>VMT Hook是最好的Hook方法之一，因为没有API或者检测这类Hook的通用方法。 但大多数反作弊引擎都会在D3D渲染引擎上检测VMT Hook。当然，只要你有经验，你的Hook就不会被检测</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>逆向</tag>
        <tag>Hook</tag>
        <tag>虚函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Zeek源码分析（1）</title>
    <url>/2022/10/08/zeek-soucre-code-analysis-1/</url>
    <content><![CDATA[<h1 id="zeek的主循环">Zeek的主循环</h1>
<h2 id="io循环">IO循环</h2>
<p>查阅资料得知，在Zeek 3.1之前，Zeek的主循环使用轮询忙等待来检查是否有Ready的IO源，来处理的数据、事件</p>
<p>在3.1之后，Zeek 转而依赖于操作系统的内置的IO多路复用来fd上的更改，所以引入了 libkqueue</p>
<p>libkqueue是个跨平台的IO多路复用实现。它在 macOS 和 FreeBSD 下使用 kqueue 实现，在 Linux 系统下实际使用 epoll 实现（epoll不可用时使用poll实现）</p>
<p>在创建新的IO源时，会向IO源管理器注册fd。当源有要处理的数据时，此fd用于通知 kqueue，将新数据的处理推入 IO 源。而不是我们问源是否有事情要做</p>
<a id="more"></a>
<h2 id="zeek主循环干了哪些事">Zeek主循环干了哪些事？</h2>
<ol type="1">
<li>遍历处理就绪的 IO 源（如拿到NIC中的包、触发定时器等）</li>
<li>更新全局的network_time并触发定时器</li>
<li>派发事件队列中的所有事件</li>
<li>判断是否有中断、终结信号</li>
<li>更新统计数据</li>
</ol>
<h1 id="zeek脚本中functioneventhook的区别">Zeek脚本中Function、Event、Hook的区别</h1>
<table>
<thead>
<tr class="header">
<th></th>
<th>匿名</th>
<th>多实现和优先级</th>
<th>立即调用</th>
<th>可调度</th>
<th>默认参数</th>
<th>引用类型参数可变性</th>
<th>备用声明</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Function</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>√</td>
</tr>
<tr class="even">
<td>Hook</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr class="odd">
<td>Event</td>
<td>×</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
</tbody>
</table>
<h1 id="侵入式指针">侵入式指针</h1>
<p>一种智能指针。和<code>std::shared_ptr</code>语义一致</p>
<p><code>std::shared_ptr</code>的引用计数与Object无关，由<code>std::shared_ptr</code>存储</p>
<p>而侵入式指针的引用计数由Object内部存储</p>
<p>这样的设计可以避免出现两个Control Block管理一个Object的情况</p>
<p>看一下以下错误代码片段： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A* raw_p = <span class="keyword">new</span> A;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;A&gt; <span class="title">p</span><span class="params">(raw_p)</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;A&gt; <span class="title">p2</span><span class="params">(raw_p)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">250</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显可以看出编写者对<code>std::shared_ptr</code>理解不够深刻。这是一段等着死的代码。因为p和p2各自维护了自己的引用计数</p>
<p>创建时都加1，销毁时都减1，结果把A delete了两次</p>
<p>所以安全的使用<code>std::shared_ptr</code>得充分理解<code>make_shared</code>和<code>enable_shared_from_this</code></p>
<p>而使用侵入式指针就不需要考虑这些事情</p>
<p>优点：</p>
<ul>
<li>优于<code>std::shared_ptr</code>的性能。使用<code>make_shared</code>时会有两次new操作，一次是指针本身，一次是引用计数</li>
<li>避免同一个Object被多个引用计数管理导致double free。</li>
</ul>
<p>缺点：</p>
<ul>
<li>所有类都要继承基类。耦合性过高</li>
</ul>
<blockquote>
<p>实际上如果观察基于引用计数来GC的语言，比如Python，就会发现基类PyObject就是侵入式引用计数</p>
</blockquote>
<h1 id="zeek运行时的数据流">Zeek运行时的数据流</h1>
<p>TFTP数据包到达<code>Analyzer</code>的过程</p>
<p>调用栈： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">evnet <span class="title">tftp_read_request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">....  <span class="comment">// 此处省略事件管理器分发事件的过程...</span></span></span><br><span class="line"><span class="function"><span class="comment">/*------------- Zeek脚本事件开始 -------------*/</span></span></span><br><span class="line"><span class="function">analyzer::tftp::<span class="title">TFTP_Analyzer::DeliverPacket</span><span class="params">()</span> <span class="comment">// 分析出TFTP的操作码、文件名等信息</span></span></span><br><span class="line"><span class="function"><span class="comment">/*------------- 应用层协议分析开始 -------------*/</span></span></span><br><span class="line"><span class="function">analyzer::pia::<span class="title">PIA::ReplayPacketBuffer</span><span class="params">()</span> <span class="comment">// 将之前构造的Buffer里的负载全部转给协议分析器（包括匹配之前所有同会话的负载）</span></span></span><br><span class="line"><span class="function">analyzer::pia::<span class="title">PIA_UDP::ActivateAnalyzer</span><span class="params">()</span> <span class="comment">// 实例化TFTP_Analyzer，并放入UDPSessionAdapter子分析器列表</span></span></span><br><span class="line"><span class="function">detail::<span class="title">RuleActionEnable::DoAction</span><span class="params">()</span> <span class="comment">// 启动dpd.sig里指定的协议分析器（enable tftp）</span></span></span><br><span class="line"><span class="function">detail::<span class="title">RuleMatcher::ExecRuleActions</span><span class="params">()</span> <span class="comment">// 执行匹配到的dpd.sig里的Action和Dependency Conditions</span></span></span><br><span class="line"><span class="function">detail::<span class="title">RuleMatcher::Match</span><span class="params">()</span> <span class="comment">// 将负载输入所有相关匹配器中，检查Conditions（Header、Content）</span></span></span><br><span class="line"><span class="function">detail::<span class="title">RuleMatcherState::Match</span><span class="params">()</span> <span class="comment">// 调用rule_matcher-&gt;Match</span></span></span><br><span class="line"><span class="function">analyzer::pia::<span class="title">PIA::DoMatch</span><span class="params">()</span> <span class="comment">// 检查RuleEndpointState是否初始化，否则初始化。转发给基类处理</span></span></span><br><span class="line"><span class="function">analyzer::pia::<span class="title">PIA::PIA_DeliverPacket</span><span class="params">()</span> <span class="comment">// 添加到Buffer中（详见细节11）</span></span></span><br><span class="line"><span class="function">analyzer::pia::<span class="title">PIA_UDP::DeliverPacket</span><span class="params">()</span> <span class="comment">// 转发给基类PIA处理</span></span></span><br><span class="line"><span class="function">analyzer::<span class="title">Analyzer::NextPacket</span><span class="params">()</span> <span class="comment">// 先给SupportAnalyzer（如果存在），然后将数据转发到DeliverPacket</span></span></span><br><span class="line"><span class="function">analyzer::<span class="title">Analyzer::ForwardPacket</span><span class="params">()</span> <span class="comment">// 转发给当前会话的所有协议分析器(和当前端口绑定的协议分析器、PIA、ConnSize)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*------------- 匹配dpd.sig开始 -------------*/</span></span></span><br><span class="line"><span class="function">packet_analysis::UDP::<span class="title">UDPAnalyzer::DeliverPacket</span><span class="params">()</span> <span class="comment">// 分析出源端口、目标端口、负载长度等</span></span></span><br><span class="line"><span class="function">packet_analysis::IP::<span class="title">IPBasedAnalyzer::AnalyzePacket</span><span class="params">()</span> <span class="comment">// 创建Connection并放到session_mgr里，构造UDPSessionAdapter树（详见细节9）</span></span></span><br><span class="line"><span class="function">packet_analysis::<span class="title">Analyzer::ForwardPacket</span><span class="params">()</span> <span class="comment">// 转发给对应的传输层包分析器</span></span></span><br><span class="line"><span class="function">packet_analysis::IP::<span class="title">IPAnalyzer::AnalyzePacket</span><span class="params">()</span> <span class="comment">// IP包分析器，分析出IP地址、传输层协议类型等</span></span></span><br><span class="line"><span class="function">packet_analysis::<span class="title">Analyzer::ForwardPacket</span><span class="params">()</span> <span class="comment">// 转发给对应的网络层包分析器</span></span></span><br><span class="line"><span class="function">packet_analysis::Ethernet::<span class="title">EthernetAnalyzer::AnalyzePacket</span><span class="params">()</span> <span class="comment">// 以太网包分析器，分析出Mac地址、网络层协议类型等</span></span></span><br><span class="line"><span class="function">packet_analysis::<span class="title">Analyzer::ForwardPacket</span><span class="params">()</span> <span class="comment">// root_analyzer送到对应的数据链路层包分析器中</span></span></span><br><span class="line"><span class="function">packet_analysis::<span class="title">Manager::ProcessPacket</span><span class="params">()</span> <span class="comment">// packet_mgr开始处理包</span></span></span><br><span class="line"><span class="function"><span class="comment">/*------------- 包分析开始 -------------*/</span></span></span><br><span class="line"><span class="function">run_state::<span class="title">detail::dispatch_packet</span><span class="params">()</span> <span class="comment">// 将包交给packet_mgr处理</span></span></span><br><span class="line"><span class="function">iosource::<span class="title">PktSrc::Process</span><span class="params">()</span> <span class="comment">// 发现有数据包到来并处理</span></span></span><br><span class="line"><span class="function">run_state::<span class="title">detail::run_loop</span><span class="params">()</span> <span class="comment">// 主循环</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>IO源循环中，发现有数据包到来。执行<code>IOSource::Process()</code>，调用派生类<code>PcapSource</code>实现的纯虚函数<code>ExtractNextPacket</code>取到包，再调用<code>dispatch_packet</code></li>
<li><code>dispatch_packet</code>中调用<code>packet_mgr-&gt;ProcessPacket(pkt)</code>开始处理包</li>
<li>调用<code>root_analyzer-&gt;ForwardPacket</code>将包送到对应的二层包分析器的<code>AnalyzePacket</code>函数里</li>
<li>先进入<code>EthernetAnalyzer</code>类，分析出源Mac地址和目标Mac地址，以及上层协议是IP，然后将包转发给<code>IPAnalyzer</code>类【数据链路层】</li>
<li><code>IPAnalyzer</code>类分析出IP协议版本、源IP地址、是否分片、上层协议等等信息。并验证checksum等，最后将包转发给<code>UDPAnalyzer</code>类【网络层】</li>
<li><code>UDPAnalyzer</code>类先由基类<code>IPBasedAnalyzer</code>创建Connection（并触发new_connection事件）并放到session_mgr里、构造<code>UDPSessionAdapter</code>树；然后解析源端口、目标端口、负载长度等。最后将包转发给<code>UDPSessionAdapter</code>处理【传输层】</li>
<li><code>UDPSessionAdapter</code>通过<code>PIA</code>分析器的<code>Match</code>函数匹配dpd.sig，匹配到后调用<code>ExecRuleActions</code>函数执行<code>enable tftp</code></li>
<li><code>enable tftp</code>，会先将<code>TFTP_Analyzer</code>添加到<code>UDPSessionAdapter</code>子分析器列表中，随后调用<code>analyzer_mgr-&gt;InstantiateAnalyzer</code>函数实例化一个<code>TFTP_Analyzer</code>对象</li>
<li>将UDP的负载通过<code>PIA</code>分析器的<code>ReplayPacketBuffer</code>函数<code>DeliverPacket</code>传递给<code>TFTP_Analyzer</code>对象</li>
<li><code>TFTP_Analyzer</code>分析出TFTP的操作码、文件名等信息【应用层】</li>
<li>最后通过自定义实现的事件通知到Zeek脚本</li>
</ol>
<p>一些细节：</p>
<ol type="1">
<li><code>dispatch_packet</code>函数在第一个包到来前会触发<code>network_time_init</code>事件</li>
<li><code>root_analyzer-&gt;ForwardPacket</code>会触发触发<code>raw_packet</code>事件</li>
<li><code>IPAnalyzer</code>类会分析IPv6的包有没有扩展标头，比如有ESP的话就触发esp_packet事件。且说明负载被加密，不执行后面的操作</li>
<li><code>TCPAnalyzer</code>、<code>UDPAnalyzer</code>都继承自<code>IPBasedAnalyzer</code>，因为基于IP的数据包，分析器的很多代码是一致的</li>
<li><code>IPBasedAnalyzer</code>会检查Connection是否reused，如果是会触发connection_reused事件，并重新将Connection放到session_mgr里</li>
<li><code>IPBasedAnalyzer</code>会触发new_packet事件</li>
<li><code>UDPAnalyzer</code>类会触发udp_request或udp_reply事件</li>
<li>所有的协议分析器都是树形结构的，根节点都是其传输层协议的会话适配器（<code>UDPSessionAdapter</code>、<code>TCPSessionAdapter</code>等）</li>
<li><code>UDPSessionAdapter</code>树构造时，会检查并添加与端口绑定的协议分析器；以及增加<code>PIA</code>分析器、<code>ConnSize</code>分析器</li>
<li><code>PIA</code>分析器为TCP和UDP提供通用功能，可用于确定使用哪个协议分析器对其进行解析，也就是匹配dpd.sig；也提供reassembles包的功能</li>
<li><code>PIA</code>分析器里的<code>Buffer</code>用双向链表将包负载连起来，用于保存数据包有效载荷（包括 TCP 的序列号）和reassembles</li>
</ol>
<h1 id="源码中各种全局manager的用途">源码中各种全局Manager的用途</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 预分配一些简单的Val对象（bool、port、空string等）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用侵入式指针做共享所有权管理，以便资源复用。避免无谓的内存分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ValManager* val_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 维护和调度（链路层、传输层、网络层）包分析器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 维护分析器名称与标识的映射、为数据包分配包分析器、转储数据包等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">packet_analysis::Manager* packet_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 维护和调度（应用层）协议分析器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 维护分析器名称与标识的映射、为新连接初始化分析器树、给指定端口指定分析器等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">analyzer::Manager* analyzer_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 插件管理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 加载动态插件、初始化插件里的bif、管理插件的钩子等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">plugin::Manager* plugin_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 签名管理器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注册协议分析器内的.sig文件、识别文件的MIME类型等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">detail::RuleMatcher* detail::rule_matcher;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 异步DNS正向/反向查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">detail::DNS_Mgr* detail::dns_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定时器管理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 内部维护了优先级队列，每个任务会添加时间戳，最近的时间戳的任务会先出队</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">detail::TimerMgr* detail::timer_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 日志流管理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建/移除/开启/关闭日志流、设置筛选器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">logging::Manager* log_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 线程管理器，负责协调所有子线程， 每个 BasicThread 都会被添加到管理器，直到终止后被删除</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 线程可以直接发送Zeek事件；MsgThread 还可以定时触发心跳</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">threading::Manager* thread_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输入流管理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用于实现输入框架</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">input::Manager* input_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件分析器交互的主要入口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提供解析协议中文件的各种接口：文件重组、MIME检测等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">file_analysis::Manager* file_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 管理Zeek脚本文件文档的跟踪和生成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">zeekygen::detail::Manager* detail::zeekygen_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IO源管理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 初始化注册IO源，然后在主循环中轮询处理Ready的IO源</span></span><br><span class="line"><span class="comment"> * IO源不仅限于pcap，NIC，也包括broker_mgr、timer_mgr、event_mgr等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">iosource::Manager* iosource_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 管理 Zeek 进程间通信</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 进程间事件分发、日志流分发等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Broker::Manager* broker_mgr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件管理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 事件入队，用于触发Zeek事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventMgr event_mgr；</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当前活动会话的管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">session::Manager* session_mgr;</span><br></pre></td></tr></table></figure>
<h1 id="从zeek源码中的回调函数引发的对面向对象的思考">从Zeek源码中的回调函数引发的对面向对象的思考</h1>
<h2 id="回调函数">回调函数</h2>
<p>回调函数是编码中常用的一种手段，用于实现异步操作、事件响应等</p>
<p>在C/C++中，实现回调的方法很多，比如最常用、简单的函数指针</p>
<p>在Zeek源码中的回调函数（如Timer的回调）几乎都是使用多态实现的</p>
<p>其实不难看出为什么使用多态实现，因为Zeek的代码几乎全部是OOP的，而函数指针指向成员函数比较的麻烦（并不是不能，需要写丑陋的using/typedef，而且调用时还需要传递this指针，破坏了OOP。或者直接干脆用static成员函数）</p>
<p>使用多态实现的回调既不会破坏OOP、也提供不错的回调性能（比函数指针多一次对虚表的内存寻址）</p>
<p>但也有一定的缺点，比如：</p>
<ol type="1">
<li>由于继承是强耦合的，如果新需求到来需要再加一个回调的业务实现，那么就需要一个新的派生类</li>
<li>代码可读性的下降</li>
</ol>
<p>借此我们可以思考一下，有没有更好的写法</p>
<p>其实Modern C++指导思想下的写法就是使用<code>std::function</code> + 弱回调实现</p>
<p>好处如下：</p>
<ol type="1">
<li><code>std::function</code>可以接受一个C函数、C++成员函数、仿函数或lambda，更灵活</li>
<li>使用<code>std::bind</code>可以顺便保存响应函数的参数，将回调函数和回调上下文绑定起来，实现闭包</li>
<li>弱回调可以保证不影响（延长）对象生命周期，且对象销毁后触发回调也不会导致段错误</li>
<li>良好的代码可读性和良好的回调性能</li>
</ol>
<blockquote>
<p>弱回调的实现方法：利用<code>std::weak_ptr</code>，在回调的时候先尝试提升为<code>std::shared_ptr</code>，如果提升成功，说明接受回调的对象还在，执行回调；如果提升失败就忽略</p>
</blockquote>
<h1 id="对面向对象的思考">对面向对象的思考</h1>
<p>其实这样的思想就是函数式编程，把数据和计算放到闭包里，而OOP是把数据和操作放到对象里</p>
<p>可以看出Zeek源码的编写者是非常愿意拥抱现代C++的（C++17标准、<code>std::string_view</code>等的使用）。但他们很明显还在使用过时的设计思想。他们尝试把一切都使用OOP编写，也就是“纯”面向对象</p>
<p>计算机科学界有很多声音批判“纯”面向对象的声音</p>
<p>王垠的 <a href="https://www.yinwang.org/blog-cn/2013/03/07/design-patterns">解密“设计模式”</a> 批判了（面向对象）设计模式的 “历史局限性”：</p>
<blockquote>
<p>（设计模式）变成了一种教条，带来了公司里程序的严重复杂化以及效率低下 ... 什么都得放进 class 里 ... 代码弯了几道弯，让人难以理解。</p>
</blockquote>
<p>孟岩的 <a href="https://blog.csdn.net/myan/article/details/5928531">function/bind的救赎（上）</a> 也提到 “面向类编程” 脱离了 “对象的本质”：</p>
<blockquote>
<p>C++ 静态消息机制 还引起了更深严重的问题 —— 扭曲了人们对面向对象的理解 ... “面向对象编程” 变成了 “面向类编程”，“面向类编程” 变成了 “构造类继承树”。</p>
</blockquote>
<h1 id="如何进行代码设计">如何进行代码设计？</h1>
<p>假设我们需要实现一个“异步下载”的功能，我们看如何进行实现</p>
<h2 id="面向过程朴素设计">面向过程——朴素设计</h2>
<p>下载完成后<strong>打印结果</strong>可以实现为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownloadAsyncAndPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... download async and construct |result| ...</span></span><br><span class="line">  <span class="built_in">Print</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下载完成后<strong>写数据库</strong>可以实现为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownloadAsyncAndWriteToDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... download async and construct |result| ...</span></span><br><span class="line">  <span class="built_in">WriteToDB</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现异步下载这部分功能是公共逻辑，所以可以通过<strong>抽取函数</strong>(extract function)手法来重构出异步下载的核心逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::future&lt;Result&gt; <span class="title">DownloadAsyncImpl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownloadAsyncAndPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Result result = <span class="keyword">co_await</span> <span class="built_in">DownloadAsyncImpl</span>();</span><br><span class="line">  <span class="built_in">Print</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownloadAsyncAndWriteToDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Result result = <span class="keyword">co_await</span> <span class="built_in">DownloadAsyncImpl</span>();</span><br><span class="line">  <span class="built_in">WriteToDB</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在的问题： - 不可能针对所有需求提供上述接口（有人需要打印结果，有人需要写数据库，还有人需要...） - 需要提供<strong>不涉及实现细节</strong>的接口（比如 <code>DownloadAsyncImpl</code> 基于 C++ 20 的协程，可以改用多线程实现，但调用者并不关心）</p>
<p>本质上，面向过程的结构化设计，导致数据 result 生产和消费的逻辑<strong>耦合</strong>在了一起，不易于扩展</p>
<h2 id="面向对象解耦发送者和接收者">面向对象——解耦发送者和接收者</h2>
<p>为了解决这个问题，需要引入<strong>控制反转</strong>(IoC)，从<strong>纯面向对象</strong>的视角看：</p>
<ul>
<li>一个数据：result</li>
<li>两个角色：发送者（<code>ownloadAsyncImpl</code>）和 接收者（<code>Print/WriteToDB</code>）</li>
</ul>
<p>而目的是解耦送者和接收者，可以通过以下两种方法实现</p>
<h2 id="模板模式">模板模式</h2>
<p>通过<strong>继承</strong>，在发送者（虚基类）上<strong>重载</strong>接收者（纯虚方法）逻辑：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Downloader</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Downloader</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DownloadAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Result result = <span class="keyword">co_await</span> <span class="built_in">DownloadAsyncImpl</span>();</span><br><span class="line">    <span class="built_in">Handle</span>(result);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Handle</span><span class="params">(<span class="type">const</span> Result&amp; result)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client code</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintDownloader</span> : <span class="keyword">public</span> Downloader &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Handle</span><span class="params">(<span class="type">const</span> Result&amp; result)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Print</span>(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> print_downloader = std::<span class="built_in">make_unique</span>&lt;PrintDownloader&gt;();</span><br><span class="line">print_downloader-&gt;<span class="built_in">DownloadAsync</span>();</span><br></pre></td></tr></table></figure>
<h2 id="策略模式">策略模式</h2>
<p>通过<strong>组合</strong>，向发送者（类/函数）<strong>传递</strong>接收者（派生类）逻辑：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Handler</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Handle</span><span class="params">(<span class="type">const</span> Result&amp; result)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownloadAsync</span><span class="params">(std::unique_ptr&lt;Handler&gt; handler)</span> </span>&#123;</span><br><span class="line">  Result result = <span class="keyword">co_await</span> <span class="built_in">DownloadAsyncImpl</span>();</span><br><span class="line">  handler-&gt;<span class="built_in">Handle</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client code</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WriteToDBHandler</span> : <span class="keyword">public</span> Handler &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Handle</span><span class="params">(<span class="type">const</span> Result&amp; result)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">WriteToDB</span>(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">DownloadAsync</span>(std::<span class="built_in">make_unique</span>&lt;WriteToDBHandler&gt;());</span><br></pre></td></tr></table></figure>
<p>在实际的代码编写中，如果能写出以上两种设计的代码，其实已经足够好了。但依然有以下缺点： - 模板模式在运行时不能动态更换接收者 - 策略模式要为每种类型定义一个接收者的接口</p>
<p>在Zeek的源码中，各种分析器（<code>Analyzer</code>）就是基于模板模式设计的</p>
<p>而策略模式也有应用，比如<code>RuleCondition</code>、<code>Timer</code>等</p>
<p>本质上，面向对象的<strong>封装</strong>把<strong>数据</strong>和<strong>对数据的操作（方法）</strong>捆绑在类里，引入了复杂的<strong>类层次结构</strong>(class hierarchy)，最后沦为<strong>面向类编程</strong></p>
<img data-src="/2022/10/08/zeek-soucre-code-analysis-1/class.png" class="">
<h2 id="回调闭包">回调闭包</h2>
<p>其实，可以使用<strong>回调闭包</strong>(callback closure) 实现等效的<strong>依赖注入</strong> (DI) 功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">using</span> OnDoneCallable = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> Result&amp; result)&gt;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownloadAsync</span><span class="params">(OnDoneCallable callback)</span> </span>&#123;</span><br><span class="line">  Result result = <span class="keyword">co_await</span> <span class="built_in">DownloadAsyncImpl</span>();</span><br><span class="line">  <span class="built_in">callback</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client code</span></span><br><span class="line"><span class="built_in">DownloadAsync</span>(std::<span class="built_in">bind</span>(&amp;Print));</span><br></pre></td></tr></table></figure>
<p>上述代码去掉了class，把 handler 对象改为 callback 闭包，把 虚函数调用 改为 回调闭包的调用，不再需要接口和继承</p>
<p>脱离了 “类” 的束缚，是不是 清晰多了</p>
<h2 id="泛型编程">泛型编程</h2>
<p>实际上，也可以使用<strong>泛型编程</strong>(generic programming) 进一步化简</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OnDoneCallable&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DownloadAsync</span><span class="params">(OnDoneCallable callback)</span> </span>&#123;</span><br><span class="line">  Result result = <span class="keyword">co_await</span> <span class="built_in">DownloadAsyncImpl</span>();</span><br><span class="line">  <span class="built_in">callback</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client code</span></span><br><span class="line"><span class="built_in">DownloadAsync</span>(std::<span class="built_in">bind</span>(&amp;Print));</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>其实各种编程范式的争论，在计算机科学领域一直喋喋不休</p>
<p>比如在C++标准库中，各种容器就是泛型编程的思想</p>
<p>而在Java标准库中，各种容器的迭代器基于<code>Iterable</code>接口、对象的比较基于<code>Comparable</code>接口</p>
<p>在本质上并没有谁更好谁更坏</p>
<p>能够随着项目入乡随俗，不单单是写出命名风格、缩进风格一致的代码，更要写出设计一致、默认正确的代码</p>
<p>这是一个优秀程序员的基本功</p>
<p>函数模板<code>DownloadAsync&lt;&gt;</code>只关心 callback 能处理 result，而不需要关心它的实际类型是什么</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://zeek.org/">Zeek</a></li>
<li><a href="https://github.com/zeek/zeek/wiki/IntrusivePtr-Overview">IntrusivePtr Overview</a></li>
<li><a href="https://bot-man-jl.github.io/articles/?post=2019/Callback-vs-Interface-Explained">再谈“回调 vs 接口”设计</a></li>
</ul>
]]></content>
      <categories>
        <category>Zeek</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>源码分析</tag>
        <tag>Zeek</tag>
        <tag>IDS</tag>
        <tag>网络安全</tag>
        <tag>面向对象设计</tag>
      </tags>
  </entry>
  <entry>
    <title>ZeekCtl源码分析</title>
    <url>/2022/11/21/zeekctl-soucre-code-analysis/</url>
    <content><![CDATA[<h1 id="deploy流程">deploy流程</h1>
<h2 id="一.-check">一. check</h2>
<ol type="1">
<li>创建<code>&#123;prefix&#125;/spool/tmp/check-config-XXXXX</code>目录</li>
<li>将install命令应生成的zeek脚本放入临时目录</li>
<li>运行<code>check-config</code>脚本,启动所有node（不收包，跑完zeek脚本后正常退出）</li>
<li>检查node的exitcode是否为0</li>
</ol>
<h2 id="二.-install">二. install</h2>
<ol type="1">
<li>删除以前安装的策略文件以避免混淆</li>
<li>在<code>&#123;prefix&#125;/spool/installed-scripts-do-not-touch</code>下创建<code>size</code>和<code>auto</code>目录,分别存放站点策略和配置信息</li>
<li>安装本地站点策略（将<code>&#123;prefix&#125;/share/zeek/site/local.zeek</code>拷贝到策略文件目录）</li>
<li>创建包含集群布局的Zeek脚本<code>cluster-layout.zeek</code></li>
<li>创建包含本地网络列表的Zeek脚本<code>local-networks.zeek</code></li>
<li>创建包含zeekctl配置的Zeek脚本<code>zeekctl-config.zeek</code></li>
<li>将logger节点的工作目录软连接到<code>&#123;prefix&#125;/logs/current</code></li>
</ol>
<a id="more"></a>
<h2 id="三.-stop">三. stop</h2>
<ol type="1">
<li>检查节点是否意外崩溃，如果是则生成崩溃报告</li>
<li>调用<code>stop</code>脚本对节点发送SIGTERM信号</li>
<li>再次检查节点是否正常终止（默认timeout 60秒）</li>
<li>如果还在运行，就使用SIGKILL信号，强行终止</li>
<li>运行<code>post-terminate</code>脚本为节点进行清理任务</li>
</ol>
<p>Zeek终止后的清理任务： 1. 将节点的工作目录移动到tmp目录并创建新的工作目录。如果节点崩溃，则创建崩溃报告 2. 尝试归档所有日志（如果失败，则发送电子邮件），最后（如果节点没有崩溃），如果所有日志都成功归档，则删除tmp目录</p>
<h2 id="四.-start">四. start</h2>
<ol type="1">
<li>忽略仍在运行的节点</li>
<li>检查节点是否意外崩溃，如果是则生成崩溃报告</li>
<li>创建节点工作目录<code>&#123;prefix&#125;/spool/XXXX</code></li>
<li>运行<code>start</code>脚本启动节点</li>
<li>检查进程是否确实启动了</li>
</ol>
<p><code>start</code>脚本： 1. 检查当前用户是否有工作进程读写权限 2. 不挂起并在后台运行<code>run-zeek</code>脚本启动zeek，并将标准输出和标准错误分别重定向到<code>stdout.log</code>和<code>stderr.log</code> 3. 循环等待<code>.pid</code>文件，获取Zeek的PID并回写给zeekctl</p>
<p><code>run-zeek</code>脚本： 1. 使用<code>ulimit</code>命令解锁各种资源限制，并写入<code>stdout.log</code> 2. 将环境变量写入<code>.env_vars</code> 3. 将Zeek命令行写入<code>.cmdline</code> 4. 将当前时间写入<code>.startup</code> 5. 不挂起并在后台启动zeek，如果有pin_cpu就使用<code>taskset</code>命令设置亲和性 6. 将Zeek的PID写入<code>.pid</code> 7. 等待zeek进程</p>
<h2 id="q-a">Q &amp; A</h2>
<blockquote>
<p>Q: 为啥check检查不到zeek监听端口冲突等问题？</p>
<p>A: 因为<code>check-config</code>启动时会设置环境变量<code>ZEEKCTL_CHECK_CONFIG=1</code>,zeek不会在群集中建立节点之间通信，自然不会监听端口，也就不会引发异常</p>
</blockquote>
<h1 id="netstats流程">netstats流程</h1>
<ol type="1">
<li>zeekctl调用<code>_send_event_init</code>发送<code>Control::net_stats_request</code>事件</li>
<li>worker节点触发<code>Control::net_stats_request</code>事件，计算出网络状态</li>
<li>worker节点触发<code>Control::net_stats_response</code>事件，将消息传回zeekctl</li>
<li>zeekctl调用<code>_send_event_wait</code>取到消息</li>
</ol>
<p><code>_send_event_init</code>实现细节： 1. 创建端点 2. 创建数据订阅者和状态订阅者 3. 建立连接 4. 等待连接建立（通过状态订阅者查看连接状态） 5. 构建Event并通过数据订阅者publish给Zeek</p>
<h1 id="多个zeekctl之间如何竞争资源">多个zeekctl之间如何竞争资源？</h1>
<h2 id="文件实现的多进程锁">文件实现的多进程锁</h2>
<p>zeekctl使用函数装饰器让命令在执行前上锁，执行后解锁</p>
<h2 id="上锁流程">上锁流程</h2>
<ol type="1">
<li>获取当前zeekctl的PID</li>
<li>创建<code>&#123;prefix&#125;/spool/lock.XXXX</code>文件，并写入PID</li>
<li>尝试将<code>lock.XXXX</code>硬链接到<code>lock</code></li>
<li>对比链接前后inode链接数，判断是否链接成功</li>
<li>如果链接成功，说明当前没有其他zeekctl进程上锁，成功上锁</li>
<li>如果链接失败，说明当前已有其他zeekctl进程上锁，上锁失败</li>
</ol>
<h2 id="上锁失败后的流程">上锁失败后的流程</h2>
<ul>
<li>如果已上锁的进程存活，则等待30秒，每隔1秒尝试获取锁</li>
<li>如果已上锁的进程已死亡，则直接删除锁文件</li>
</ul>
<h2 id="解锁流程">解锁流程</h2>
<ul>
<li>删除<code>lock</code>文件</li>
</ul>
<blockquote>
<p>除了<code>config</code>、<code>nodes</code>、<code>exec</code>命令外，其他所有命令都会上锁</p>
</blockquote>
<h1 id="deploy后zeek集群如何建立">deploy后，Zeek集群如何建立？</h1>
<blockquote>
<p>以下脚本均位于<code>base/frameworks/cluster/</code>目录下</p>
</blockquote>
<ol type="1">
<li>加载<code>main.zeek</code>：定义各种集群事件（如在其他节点成功连接上自己时，会发送hello事件给对方）、节点topic名、record类型定义</li>
<li>加载<code>pools.zeek</code>：定义用于管理群集节点池的接口。使用pools可以方便的在集群内的节点之间分发工作或数据</li>
<li>加载zeekctl在install阶段创建的包含集群布局的Zeek脚本<code>cluster-layout.zeek</code></li>
<li>判断自己是否在集群里，如果在，就加载<code>setup-connections.zeek</code>脚本，将自己连接到集群</li>
<li>根据自己的节点类型，加载不同的<code>./nodes/xxxx.zeek</code>脚本（如果集群中没有logger，那么manager也会加载logger的脚本，兼职logger）</li>
<li>加载<code>broker-stores.zeek</code>：初始化分布式键值存储接口（可以数据持久化）</li>
</ol>
<h1 id="zeek集群的布局">Zeek集群的布局</h1>
<ul>
<li><p>每个worker都连接到所有proxy。</p></li>
<li><p>所有节点连接到所有logger和manager。</p></li>
</ul>
<img data-src="/2022/11/21/zeekctl-soucre-code-analysis/cluster-layout.png" class="">
]]></content>
      <categories>
        <category>Zeek</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>Zeek</tag>
        <tag>IDS</tag>
        <tag>网络安全</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>向量化异常处理（VEH） Hook</title>
    <url>/2021/05/28/veh-hook/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>在上两个Hook文章中，我实现了<a href="/2020/12/07/vmt-hook/">虚函数表钩子（VMT Hook）</a>和<a href="/2021/03/05/iat-hook/">导入地址表（IAT）Hook</a>。</p>
<p>VMT Hook和IAT Hook的本质上都修改了内存（重定向了函数指针），所以也比较容易被检测</p>
<p>今天介绍一个不需要修改内存且几乎不会被检测的Hook，也就是向量化异常处理（VEH） Hook</p>
<h1 id="什么是veh">什么是VEH?</h1>
<p>在Windows上有着许多的异常处理方法，帮进程在遇到异常时免于崩溃。比如C++原生异常、结构化异常处理SEH（<code>__try</code>，<code>__finally</code>，<code>__except</code>就是VC++对SEH的封装）以及本文中要使用的向量化异常处理（VEH）</p>
<a id="more"></a>
<p>Windwos中的异常处理机制，当程序执行过程中发生异常时，ring0会使用<code>KiDispatchException</code>判断是否有内核调试器。如果没有调试器，ring0转交给ring3的<code>KiDispatchException</code>，开始找是否有异常处理程序（SEH、VEH）。如果已安装，会调用异常处理程序进行处理</p>
<blockquote>
<p>异常处理流程：异常产生-&gt;调试器-&gt;VEH-&gt;SEH-&gt;TopLevelEH-&gt;调试器</p>
</blockquote>
<p>由于SEH有很多缺点（基于线程、基于栈、处理优先级低），而VEH弥补了这些缺点（基于进程、且优先级高于SEH）</p>
<p>而我们可以用<code>AddVectoredExceptionHandler</code>函数注册自定义的VEH。当捕获到异常时，我们会拿到一个<a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-exception_pointers">_EXCEPTION_POINTERS</a>类型的参数。而这个参数的成员<code>ContextRecord</code>保存着异常触发时CPU各种寄存器的值，这就意味着我们可以直接修改EIP/RIP寄存器，从而达到指令跳转的目的</p>
<h1 id="如何引发异常">如何引发异常？</h1>
<ol type="1">
<li><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/memory/creating-guard-pages">PAGE_GUARD</a>：有<code>PAGE_GUARD</code>标志的内存页面，如果程序尝试访问保护页内的地址，则引发STATUS_GUARD_PAGE_VIOLATION异常。且系统还清除PAGE_GUARD标志，从而删除内存页的保护页状态。</p></li>
<li><p>NO_ACCESS: 有<code>NO_ACCESS</code>标志的内存页面，如果程序尝试访问保护页内的地址，则引发STATUS_ACCESS_VIOLATION的异常。</p></li>
<li><p>INT3断点：也可以使用INT3断点并捕获BREAKPOINT异常。但INT3断点需要修改指令，不够隐蔽</p></li>
<li><p>硬件断点：最隐蔽。但只作用于单个线程，且需要线程的句柄</p></li>
</ol>
<p>这四种都能可靠的引发异常并被VEH捕获，但使用前两种异常的同时也必须使用STATUS_SINGLE_STEP(单步异常)</p>
<p>如果你熟悉断点的原理，那么会很容易理解。STATUS_SINGLE_STEP实际上并不是严格意义上的异常，而是一种检测CPU的EFlags寄存器中的TF（跟踪标志位）的机制。当TF为1时，CPU每次仅执行一条指令，然后就引发一个STATUS_SINGLE_STEP异常</p>
<img data-src="/2021/05/28/veh-hook/flags.png" class="">
<p>上图所示<code>TF</code>在Flags寄存器16位中的第9个bit，所以我们可以通过将<code>ContextRecord</code>的<code>EFlag</code>按位或上二进制000100000000也就是0x100实现</p>
<h1 id="为什么需要单步异常">为什么需要单步异常？</h1>
<p>Windows系统在保护模式下使用内存分页机制。而一页内存是可以物理分配的最小内存量，通常是4K大小。</p>
<p>当我们用<code>VirtualProtect</code>在页面上设置保护标志时，不能作用于页面中某1个字节，而是只能作用于整个页面。</p>
<p>而绝大多数情况下，目标函数起始地址位于页面的中间。所以我们要想在这个函数起始地址触发异常，就必须使用单步异常</p>
<p>这样就可以一次在页中一条一条的执行指令，直到异常触发到目标函数起始地址的地址为止，然后修改EIP/RIP来跳转到我们的Hook函数</p>
<img data-src="/2021/05/28/veh-hook/mem-page.png" class="">
<p>假设红色地址是目标函数的起始地址。STATUS_SINGLE_STEP允许我们一步步的到达那里。而如果执行了另一个函数，但和目标函数在同一个页中，那么STATUS_SINGLE_STEP会慢慢单步直到另一个函数结束，跳出该页，且不会到达红色地址，可以有效避免钩错函数</p>
<h1 id="实现步骤">实现步骤</h1>
<ol type="1">
<li>注册VEH</li>
<li>使用<code>VirtualProtect</code>将PAGE_GUARD标志添加到目标函数的地址页</li>
<li>等待目标函数被调用，从而引发PAGE_GUARD_VIOLATION异常</li>
<li>VEH捕获异常，并跳转到Hook函数</li>
</ol>
<h1 id="封装">封装</h1>
<figure class="highlight cpp"><figcaption><span>声明</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP Rip</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP Eip</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">veh_hook</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_function&lt;F&gt;::value, <span class="string">&quot;veh hook require the function&quot;</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">veh_hook</span>(F* original_func, F* hook_func);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">enable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">disable</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">are_in_same_page</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> LONG WINAPI <span class="title">handler</span><span class="params">(EXCEPTION_POINTERS* exception_info)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> F* m_original_func;</span><br><span class="line">    <span class="type">static</span> F* m_hook_func;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* m_veh_handle;</span><br><span class="line">    <span class="type">static</span> DWORD m_old_protection;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">F* veh_hook&lt;F&gt;::m_original_func = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">F* veh_hook&lt;F&gt;::m_hook_func = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="type">void</span>* veh_hook&lt;F&gt;::m_veh_handle = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">DWORD veh_hook&lt;F&gt;::m_old_protection = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function">veh_hook&lt;F&gt; <span class="title">make_veh_hook</span><span class="params">(F* original_func, F* hook_func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">veh_hook</span>&lt;F&gt;(original_func, hook_func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><figcaption><span>实现</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">veh_hook&lt;F&gt;::<span class="built_in">veh_hook</span>(F* original_func, F* hook_func) &#123;</span><br><span class="line">    m_original_func = original_func;</span><br><span class="line">    m_hook_func = hook_func;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="type">void</span> veh_hook&lt;F&gt;::<span class="built_in">enable</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_veh_handle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_original_func || !m_hook_func)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to enable veh hook : original/hook function can&#x27;t be nullptr!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能Hook在同一页面的两个函数，会无限回调</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">are_in_same_page</span>())</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to enable veh hook : two functions in the same page!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加VEH</span></span><br><span class="line">        m_veh_handle = <span class="built_in">AddVectoredExceptionHandler</span>(<span class="literal">true</span>, handler);</span><br><span class="line">        <span class="keyword">if</span> (!m_veh_handle)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to enable veh hook : add veh failed!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给目标函数的页面加上PAGE_GUARD标志</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(m_original_func, <span class="number">1</span>, PAGE_EXECUTE_READ | PAGE_GUARD, &amp;m_old_protection))</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to enable veh hook : modify memory protection failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="type">void</span> veh_hook&lt;F&gt;::<span class="built_in">disable</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_veh_handle) &#123;</span><br><span class="line">        DWORD _;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(m_original_func, <span class="number">1</span>, m_old_protection, &amp;_)) <span class="comment">// 恢复内存保护</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to disable veh hook : modify memory protection failed!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">RemoveVectoredExceptionHandler</span>(m_veh_handle)) <span class="comment">// 移除VEH</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to disable veh hook : remove veh failed!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        m_veh_handle = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="type">bool</span> veh_hook&lt;F&gt;::<span class="built_in">are_in_same_page</span>() &#123;</span><br><span class="line">    MEMORY_BASIC_INFORMATION mbi1;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualQuery</span>(m_original_func, &amp;mbi1, <span class="built_in">sizeof</span>(mbi1)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    MEMORY_BASIC_INFORMATION mbi2;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualQuery</span>(m_hook_func, &amp;mbi2, <span class="built_in">sizeof</span>(mbi2)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbi1.BaseAddress == mbi2.BaseAddress) <span class="comment">// 看看页起始地址是否相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 在同一页，返回true使enable函数抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">LONG WINAPI veh_hook&lt;F&gt;::<span class="built_in">handler</span>(EXCEPTION_POINTERS* exception_info) &#123;</span><br><span class="line">    <span class="comment">// 捕获PAGE_GUARD_VIOLATION异常</span></span><br><span class="line">    <span class="keyword">if</span> (exception_info-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_GUARD_PAGE_VIOLATION) &#123;</span><br><span class="line">        <span class="comment">// 如果EIP/RIP是目标函数，就修改EIP/RIP来跳转到Hook函数</span></span><br><span class="line">        <span class="keyword">if</span> (exception_info-&gt;ContextRecord-&gt;IP == <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(m_original_func)) &#123;</span><br><span class="line">            exception_info-&gt;ContextRecord-&gt;IP = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(m_hook_func);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        exception_info-&gt;ContextRecord-&gt;EFlags |= <span class="number">0x100</span>; <span class="comment">// 将TF置1，下一条指令执行完后会触发SINGLE_STEP异常</span></span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION; <span class="comment">// 继续下一条指令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception_info-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_SINGLE_STEP) &#123;<span class="comment">// 捕获SINGLE_STEP异常</span></span><br><span class="line">        DWORD _;</span><br><span class="line">        <span class="built_in">VirtualProtect</span>(m_original_func, <span class="number">1</span>, PAGE_EXECUTE_READ | PAGE_GUARD, &amp;_); <span class="comment">// 重新加上PAGE_GUARD标志，因为每次触发过异常后系统都会清除它</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION; <span class="comment">// 继续下一条指令</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH; <span class="comment">// 如果不是PAGE_GUARD也不是SINGLE_STEP，就拒绝处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 钩子函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> WINAPI <span class="title">my_sleep</span><span class="params">(DWORD ms)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[?] Hooked Sleep Function Called!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sleeping for: &quot;</span> &lt;&lt; ms &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;VEH Hook Example by AmazingPP\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> hooking = <span class="built_in">make_veh_hook</span>(Sleep, my_sleep);</span><br><span class="line">    hooking.<span class="built_in">enable</span>();</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    hooking.<span class="built_in">disable</span>();</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出： <img data-src="/2021/05/28/veh-hook/output.png" class=""></p>
<p><strong>注意：由于VEH Hook并没有修改目标函数，所以如果想在Hook函数里调用原函数需要先disable()，否则会无限循环调用</strong></p>
<h1 id="总结">总结</h1>
<ul>
<li><strong>执行速度:1</strong></li>
<li><strong>编写难度:8</strong></li>
<li><strong>检测率:1</strong></li>
</ul>
<p>VEH Hook 不需要修改内存，所以非常隐蔽，而且几乎没有反作弊引擎可以检测到它</p>
<p>当然有小部分反作弊引擎用<code>VirtualQuery</code>检查PAGE_GUARD标志来检测VEH Hook，解决方法也很简单，先用VEH Hook把<code>VirtualQuery</code>钩上，筛掉PAGE_GUARD标志即可</p>
<p>但缺点也很明显，实现起来比较复杂，而且执行速度非常非常慢</p>
<p>如果对Windows的异常处理机制有更深入的了解，甚至可以钩上异常处理ring0返回ring3后调用的第一个用户态函数，也就是ntdll里的<code>KiUserExceptionDispatcher</code>，这样就可以比VEH更早的捕获到异常</p>
<h1 id="引用">引用</h1>
<p><a href="https://medium.com/@fsx30/vectored-exception-handling-hooking-via-forced-exception-f888754549c6">Vectored Exception Handling, Hooking Via Forced Exception</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>逆向</tag>
        <tag>Hook</tag>
        <tag>VEH</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出C/C++函数返回值传递原理</title>
    <url>/2021/06/30/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAC-C-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%A0%E9%80%92%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>众所周知，C/C++函数返回值会使用eax寄存器来传递，我们用以下代码验证一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n = <span class="built_in">foo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">    auto n = foo()<span class="comment">;</span></span><br><span class="line">00F22A93  <span class="keyword">call</span>        foo (<span class="number">0F213E8h</span>)  </span><br><span class="line">00F22A98  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [n],<span class="built_in">eax</span>  // <span class="built_in">ebp</span>-<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>可以看到，main函数调用完foo后，将eax的值传送到n中。证明了eax确实用于返回值传递</p>
<p>但eax本身只有4字节，那么当返回值大于4字节时是如何传递的呢？</p>
<a id="more"></a>
<h1 id="字节时">5~8字节时</h1>
<p>修改一下foo函数，返回一个8字节的值，观察一下反汇编</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">    auto n = foo()<span class="comment">;</span></span><br><span class="line">00D32A93  <span class="keyword">call</span>        fo (<span class="number">0D313EDh</span>)  </span><br><span class="line">00D32A98  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [n],<span class="built_in">eax</span>  // <span class="built_in">ebp</span>-<span class="number">8</span></span><br><span class="line">00D32A9B  <span class="keyword">mov</span>         <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>],<span class="built_in">edx</span>  </span><br></pre></td></tr></table></figure>
<p>从汇编看出，当返回一个8字节的值时，会同时使用eax和edx一起返回，其中eax给到ebp-8，edx给到ebp-4</p>
<p>根据小端模式的特点（高存高，低存低），可以看出，eax存储返回值的低4字节，而edx存储返回值的高1~4字节</p>
<h1 id="大于8字节时">大于8字节时</h1>
<p>再修改一下foo函数，让其返回一个长度为256字节的结构体 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bar</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">bar <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bar tmp;</span><br><span class="line">    tmp.buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="main函数分析">main函数分析</h2>
<p>很明显，256字节的结构体，就算用上所有通用寄存器也无法直接传递返回值</p>
<p>我们观察一下main函数的反汇编</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">00771BC0  <span class="keyword">push</span>        <span class="built_in">ebp</span>  </span><br><span class="line">00771BC1  <span class="keyword">mov</span>         <span class="built_in">ebp</span>,<span class="built_in">esp</span>  </span><br><span class="line">00771BC3  <span class="keyword">sub</span>         <span class="built_in">esp</span>,<span class="number">280h</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最一开始，保存了ebp后，将esp拉低，在栈上分配了280h个字节的空间</p>
<p>继续往下看</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">    auto n = foo()<span class="comment">;</span></span><br><span class="line">00771BC6  <span class="keyword">lea</span>         <span class="built_in">eax</span>,[<span class="built_in">ebp</span>-<span class="number">280h</span>]  </span><br><span class="line">00771BCC  <span class="keyword">push</span>        <span class="built_in">eax</span>  </span><br><span class="line">00771BCD  <span class="keyword">call</span>        foo (<span class="number">07713C5h</span>)  </span><br><span class="line">00771BD2  <span class="keyword">add</span>         <span class="built_in">esp</span>,<span class="number">4</span>  </span><br><span class="line">00771BD5  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="number">40h</span>  </span><br><span class="line">00771BDA  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">eax</span>  </span><br><span class="line">00771BDC  <span class="keyword">lea</span>         <span class="built_in">edi</span>,[n]  // <span class="built_in">ebp</span>-<span class="number">100h</span></span><br><span class="line">00771BE2  <span class="keyword">rep</span> movs    <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]  </span><br></pre></td></tr></table></figure>
<p>可以看到，在call的前面出现了两行奇怪的东西</p>
<p>第1行<code>lea eax,[ebp-280h]</code>将ebp-280h的地址存储到eax中，而ebp-280h正好指向刚才分配空间的末尾</p>
<p>接着<code>push eax</code>，将地址压入栈，然后紧接着调用foo函数。但foo函数没有任何参数呀，其实这里编译器帮我们隐式传递了一个参数，将刚才分配的栈上空间末尾指针传了进去</p>
<p>截至这里，我们可以写出伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">0x280</span>];</span><br><span class="line">foo(buf); <span class="comment">// 相当于foo(ebp-280h);</span></span><br></pre></td></tr></table></figure>
<p>继续向下看，<code>add esp,4</code>，将esp抬高4，也证明了foo函数确实有一个参数，同时也是cedcl调用约定</p>
<p>剩下的4行要整体来看，先看最后一行，<code>rep movs dword ptr es:[edi],dword ptr [esi]</code>指的是将esi指向位置上的数据，以DWORD的大小（4字节）拷贝到edi指向的位置上，拷贝ecx次</p>
<p>简单来说，最后一行就相当于<code>memcpy(edi, esi, ecx * sizeof(DWORD))</code></p>
<p>而rep movs上面的三行，分别是给ecx、esi、edi赋值的语句，含义如下</p>
<ol type="1">
<li>ecx是0x40，也就是拷贝0x40 * 4 = 256个字节的数据，和bar的大小一致</li>
<li>esi是eax，也就是foo函数的返回值</li>
<li>edi是n的地址（ebp-100h）</li>
</ol>
<p>看完这段汇编，基本上也能还原出main函数剩下的伪代码了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foo(ebp<span class="number">-280</span>h);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;n, (<span class="type">void</span>*)eax, <span class="keyword">sizeof</span>(n));</span><br></pre></td></tr></table></figure>
<h3 id="foo函数分析">foo函数分析</h3>
<p>可见，foo依然靠eax传递返回值，只不过不是直接传递函数体，而是函数体指针。foo内部到底如何实现呢？继续看一下foo的反汇编</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">bar foo() &#123;</span><br><span class="line">...</span><br><span class="line">    bar tmp<span class="comment">;</span></span><br><span class="line">    tmp<span class="number">.</span>buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span><span class="comment">;</span></span><br><span class="line">00771C36  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="number">1</span>  </span><br><span class="line">00771C3B  <span class="keyword">imul</span>        <span class="built_in">ecx</span>,<span class="built_in">eax</span>,<span class="number">0</span>  </span><br><span class="line">00771C3E  <span class="keyword">mov</span>         <span class="built_in">byte</span> <span class="built_in">ptr</span> tmp[<span class="built_in">ecx</span>],<span class="number">0</span>  </span><br></pre></td></tr></table></figure>
<p>前3行，是汇编访问数组的典型形式，相当于如下代码，这里不过多赘述 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">eax = <span class="keyword">sizeof</span>(*tmp.buf); <span class="comment">// 比例因子</span></span><br><span class="line">ecx = eax * <span class="number">0</span>; <span class="comment">// 计算与数组首地址的偏移量</span></span><br><span class="line">*((<span class="type">char</span>*)tmp + ecx) = <span class="number">0</span>; <span class="comment">// 写入0</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">    return tmp<span class="comment">;</span></span><br><span class="line">00771C46  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="number">40h</span>  </span><br><span class="line">00771C4B  <span class="keyword">lea</span>         <span class="built_in">esi</span>,[tmp]  // <span class="built_in">ebp</span>-<span class="number">100h</span></span><br><span class="line">00771C51  <span class="keyword">mov</span>         <span class="built_in">edi</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>]  </span><br><span class="line">00771C54  <span class="keyword">rep</span> movs    <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>],<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esi</span>]  </span><br><span class="line">00771C56  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>]  </span><br></pre></td></tr></table></figure>
<p>继续看，前4行依然是需要整体看，依旧是rep movs指令，根据刚才的解释，这四行可以翻译成<code>memcpy([ebp+8], &amp;tmp, 256)</code></p>
<p>接着是，<code>mov eax,dword ptr [ebp+8]</code>，将ebp+8给到eax，返回给main函数</p>
<img data-src="/2021/06/30/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAC-C-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%A0%E9%80%92%E5%8E%9F%E7%90%86/%E6%A0%88%E5%B8%A7.png" class="">
<p>根据函数栈帧的知识，我们知道ebp指向保存的旧ebp，ebp+4指向call指令压入栈的返回地址，ebp+8则指向函数的第一个参数</p>
<p>而前面根据我们分析foo函数会隐式传递一个参数来，就是main函数里的epb-280h，这样一来，思路就清晰了</p>
<h3 id="流程">流程</h3>
<ol type="1">
<li>main函数先在栈上额外开辟了一片空间，并将这块空间的一部分用于传递返回值的临时对象</li>
<li>将临时对象地址作为参数传递给foo函数</li>
<li>foo函数内将数据拷贝给临时对象，并将临时对象的地址用eax传出</li>
<li>foo函数返回后，main函数将eax指向的临时对象的内容拷贝给n</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">    bar tmp;</span><br><span class="line">    tmp.buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tmp, <span class="built_in">sizeof</span>(bar));</span><br><span class="line">    eax = ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bar tmp;</span><br><span class="line">    bar n;</span><br><span class="line">    <span class="built_in">foo</span>(&amp;tmp);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;n, eax, <span class="built_in">sizeof</span>(bar));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>在x86架构下使用Debug模式MSVC编译得出以下结论：</p>
<table>
<thead>
<tr class="header">
<th>返回值类型大小</th>
<th>传递方式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1~4字节</td>
<td>eax（ax/al）寄存器</td>
</tr>
<tr class="even">
<td>4~8字节</td>
<td>eax和edx寄存器， eax存储返回值的低4字节，而edx存储返回值的高1~4字节</td>
</tr>
<tr class="odd">
<td>8+字节</td>
<td>使用栈空间中转，进行两次拷贝</td>
</tr>
</tbody>
</table>
<p>综上所述，在没有开启任何优化的情况下，如果返回值类型过大，C/C++会使用一个临时的栈上空间做中转，进行两次拷贝。但实际上现代编译器在开启优化的情况下会使用ROV和NROV技术，以减少拷贝</p>
<h1 id="关于rov和nrov">关于ROV和NROV</h1>
<p>待完成...</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的32位Inline Hook及蹦床实现</title>
    <url>/2021/08/22/%E7%AE%80%E5%8D%95%E7%9A%8432%E4%BD%8DInline-Hook%E5%8F%8A%E8%B9%A6%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>之前介绍了很多类型的Hook，但一直都没有写最简单、最常用的Hook，也就是Inline Hook</p>
<p>其实Inline Hook是最容易被检测的Hook，且在没有做特殊处理时也是非线程安全的Hook，有极小概率在Hook时破坏运行栈，从而导致程序崩溃</p>
<p>但Inline Hook依然是最常用的Hook，因为它几乎适用任何需要Hook的场景，不存在VMT、IAT Hook需要特定场景的窘境</p>
<p>这次本文就32位下的Inline Hook和蹦床做简单的原理介绍和实现</p>
<a id="more"></a>
<h1 id="预备知识">预备知识</h1>
<p>在学习Inline Hook之前，我们得先了解几个点</p>
<ol type="1">
<li>程序被编译后会变成机器码。而在程序运行时，这些机器码是被载入内存中的(在.text段)</li>
</ol>
<p>所以，我们可以<strong>修改运行时的机器码</strong>，达到修改程序执行顺序的目的，从而实现Hook</p>
<ol start="2" type="1">
<li>无条件跳转指令（JMP）</li>
</ol>
<p>那我们只需要将被Hook的函数入口的指令改为无条件跳转到我们函数中即可</p>
<ol start="3" type="1">
<li>短跳转和长跳转</li>
</ol>
<p>其实JMP指令分为短跳转和长跳转</p>
<ul>
<li><p>短跳转：机器码为2个字节<code>EB XX</code>，E8是短JMP的机器码，XX是跳转范围-128~127</p></li>
<li><p>长跳转：机器码为5个字节<code>E9 XX XX XX XX</code>，E9是长JMP的机器码，剩下4个字节表示转移偏移量</p></li>
</ul>
<p>由于我们自己编写的函数在内存中的位置很明显不可能距离源函数只有255</p>
<p>所以Inline Hook肯定是要采用<strong>长跳转</strong>来实现，因为长跳转的寻址范围覆盖了整个32位进程的地址空间</p>
<h2 id="长jmp计算实例">长JMP计算实例</h2>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="number">00401000</span>  <span class="keyword">call</span>        <span class="keyword">jmp</span> <span class="number">402398</span></span><br><span class="line">......</span><br><span class="line"><span class="number">00402398</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>转移偏移量的公式是：目的地址 - 起始地址 - 跳转指令自身长度</p>
<p>由于长JMP指令自身长度为5，所以转移偏移量就是：<code>00402398h - 00401000h - 5h = 00001393h</code></p>
<p>而根据小端存储的原则（高存高，低存低），所以上述代码中JMP指令的机器码就是<code>E9 93 13 00 00</code></p>
<h1 id="实现">实现</h1>
<p>知道了预备知识，那么实现Inline Hook就很轻松了，只需要以下几步</p>
<ol type="1">
<li>修改内存保护</li>
<li>Nop掉原函数开头前5或6个指令（不是必要的，但是一个很好的保障措施，而且也方便调试）</li>
<li>先计算出JMP指令的转移偏移量 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">uintptr_t</span> relative_offset = function_B - function_A - <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li>
<li>将跳转指令的机器码覆盖到源函数的开头 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化JMP指令数组，第一个字节为0xE9（长JMP的机器码）</span></span><br><span class="line"><span class="type">uint8_t</span> jmp_codes[<span class="number">5</span>] = &#123; <span class="number">0xE9</span> &#125;;</span><br><span class="line"><span class="comment">// 拷贝转移偏移量到JMP指令数组的后4个字节</span></span><br><span class="line">std::<span class="built_in">memcpy</span>(jmp_codes + <span class="number">1</span>, &amp;relative_offset, <span class="built_in">sizeof</span>(relative_offset));</span><br><span class="line"><span class="comment">// 写入跳转指令的机器码到原函数开头</span></span><br><span class="line">std::<span class="built_in">memcpy</span>(src, jmp_codes, <span class="built_in">sizeof</span>(jmp_codes));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>恢复内存保护</li>
</ol>
<h2 id="完整实现">完整实现：</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">uint8_t</span> kNopCode = <span class="number">0x90</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint8_t</span> kLongJmpCode = <span class="number">0xE9</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> kStolenSize = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> kJmpCodeSize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple_x86_inline_hook</span><span class="params">(F* src, <span class="type">const</span> F* dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_function&lt;F&gt;::value, <span class="string">&quot;inline hook require a function pointer&quot;</span>);</span><br><span class="line">    <span class="comment">// 修改内存保护</span></span><br><span class="line">    DWORD cur_prot;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(src, kStolenSize, PAGE_EXECUTE_READWRITE, &amp;cur_prot))</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;VirtualProtect Error&quot;</span>);</span><br><span class="line">    <span class="comment">// Nop掉原函数开头前6个指令</span></span><br><span class="line">    std::<span class="built_in">memset</span>(src, kNopCode, kStolenSize);</span><br><span class="line">    <span class="comment">// 计算出JMP指令的转移偏移量</span></span><br><span class="line">    <span class="type">uintptr_t</span> relative_offset = </span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(dst) - <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(src) - kJmpCodeSize;</span><br><span class="line">    <span class="comment">// 初始化JMP指令数组，第一个字节为0xE9（长JMP的机器码）</span></span><br><span class="line">    <span class="type">uint8_t</span> jmp_codes[kJmpCodeSize] = &#123; kLongJmpCode &#125;;</span><br><span class="line">    <span class="comment">// 拷贝转移偏移量到JMP指令数组的后4个字节</span></span><br><span class="line">    std::<span class="built_in">memcpy</span>(jmp_codes + <span class="number">1</span>, &amp;relative_offset, <span class="built_in">sizeof</span>(relative_offset));</span><br><span class="line">    <span class="comment">// 写入跳转指令的机器码到原函数开头</span></span><br><span class="line">    std::<span class="built_in">memcpy</span>(src, jmp_codes, <span class="built_in">sizeof</span>(jmp_codes));</span><br><span class="line">    <span class="comment">// 恢复内存保护</span></span><br><span class="line">    DWORD _;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">VirtualProtect</span>(src, kJmpCodeSize, cur_prot, &amp;_))</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;VirtualProtect Error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hook函数A到函数B，反汇编后如下所示</p>
<img data-src="/2021/08/22/%E7%AE%80%E5%8D%95%E7%9A%8432%E4%BD%8DInline-Hook%E5%8F%8A%E8%B9%A6%E5%BA%8A/ah-basic-api-hook.png" class="">
<p>在Hook之前可以看到函数开头的一些原始指令(保存栈基址、开辟栈空间等操作)。但Hook之后，这些指令就被我们的JMP指令覆盖了</p>
<p>这些被覆盖的指令就叫<strong>被盗字节</strong></p>
<p>为啥JMP指令只有5个字节，但我Nop了6个字节呢？</p>
<ol type="1">
<li>方便调试，有Nop的地方意味着做了修改</li>
<li>原始的前3个指令占用了6个字节，多出来的1个字节如果不Nop掉，反汇编出的代码会很奇怪</li>
</ol>
<h1 id="蹦床">蹦床</h1>
<p>刚才我们已经实现了最简单的Inline Hook，但我们Hook一个函数后，往往只是修改参数或做一些记录，最终还是需要调用源函数的</p>
<p>但上面的实现如果尝试调用源函数会引起无限循环调用，最终导致栈溢出...</p>
<p>所以，我们还需要一个蹦床，帮我们实现可以在钩子函数中调用源函数的功能</p>
<h2 id="实现-1">实现</h2>
<p>其实蹦床的原理很简单，核心思想就是<strong>保存被盗字节</strong></p>
<p>具体实现步骤如下：</p>
<ol type="1">
<li>开辟一块空间（大小是6字节 + 5字节）作为蹦床</li>
<li>计算与原函数的JMP指令的转移偏移量</li>
<li>将被盗字节写入前6个字节</li>
<li>将JMP机器码写入后5个字节中</li>
<li>执行Inline Hook</li>
<li>将蹦床返回</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function">F* <span class="title">x86_inline_hook_tramp</span><span class="params">(F* src, <span class="type">const</span> F* dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_function&lt;F&gt;::value, <span class="string">&quot;inline hook require a function pointer&quot;</span>);</span><br><span class="line">    <span class="comment">// 开辟一块空间（大小是6字节 + 5字节）作为蹦床</span></span><br><span class="line">    <span class="type">uint8_t</span>* gateway = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(<span class="built_in">VirtualAlloc</span>(<span class="literal">nullptr</span>, kStolenSize + kJmpCodeSize,</span><br><span class="line">        MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));</span><br><span class="line">    <span class="keyword">if</span> (!gateway)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;VirtualAlloc Error&quot;</span>);</span><br><span class="line">    <span class="comment">// 计算与原函数的JMP指令的转移偏移量</span></span><br><span class="line">    <span class="type">uintptr_t</span> relative_offset =</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(src) - <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(gateway) - kJmpCodeSize;</span><br><span class="line">    <span class="type">uint8_t</span> jmp_codes[kJmpCodeSize] = &#123; kLongJmpCode &#125;;</span><br><span class="line">    std::<span class="built_in">memcpy</span>(jmp_codes + <span class="number">1</span>, &amp;relative_offset, <span class="built_in">sizeof</span>(relative_offset));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将被盗字节写入前6个字节</span></span><br><span class="line">    std::<span class="built_in">memcpy</span>(gateway, src, kStolenSize);</span><br><span class="line">    <span class="comment">// 将JMP机器码写入后5个字节中</span></span><br><span class="line">    std::<span class="built_in">memcpy</span>(gateway + kStolenSize, jmp_codes, <span class="built_in">sizeof</span>(jmp_codes));</span><br><span class="line">    <span class="comment">// 执行Inline Hook</span></span><br><span class="line">    <span class="built_in">simple_x86_inline_hook</span>(src, dst);</span><br><span class="line">    <span class="comment">// 将蹦床返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;F*&gt;(gateway);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hook函数A到函数B，并在函数B中调用原函数，反汇编后如下所示</p>
<img data-src="/2021/08/22/%E7%AE%80%E5%8D%95%E7%9A%8432%E4%BD%8DInline-Hook%E5%8F%8A%E8%B9%A6%E5%BA%8A/ah-trampoline.png" class="">
<blockquote>
<p>为啥用<code>VirtualAlloc</code>而不用<code>malloc</code>？ 因为<code>VirtualAlloc</code>可以指定内存的保护标志，而我们需要这块内存有可执行权限。<code>malloc</code>的话还需要调用一次<code>VirtualProtect</code></p>
</blockquote>
<p>简单的测试实例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于保存原函数的蹦床</span></span><br><span class="line"><span class="keyword">decltype</span>(Sleep)* src_sleep;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 钩子函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> WINAPI <span class="title">my_sleep</span><span class="params">(DWORD ms)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[?] Hooked Sleep Function Called!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sleeping for: &quot;</span> &lt;&lt; ms &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 调用源函数</span></span><br><span class="line">    <span class="built_in">src_sleep</span>(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    src_sleep = <span class="built_in">x86_inline_hook_tramp</span>(Sleep, my_sleep);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">VirtualFree</span>(src_sleep, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<ul>
<li><strong>执行速度:10</strong></li>
<li><strong>编写难度:2</strong></li>
<li><strong>检测率:7</strong></li>
</ul>
<p>像Inline Hook这种直接在.text段中修改指令的方式，非常简单和常用，也适用于绝大多数场景</p>
<p>但很容易被各种反作弊引擎检测到，不过Inline Hook的变种很多，也有很多办法可以进行隐蔽</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>逆向</tag>
        <tag>Hook</tag>
        <tag>汇编</tag>
        <tag>蹦床</tag>
      </tags>
  </entry>
</search>
